"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[554],{38386:(e,n,a)=>{a.r(n),a.d(n,{default:()=>d});var s=a(34086);const r=(0,s._)("h1",{id:"mixin",tabindex:"-1"},[(0,s._)("a",{class:"header-anchor",href:"#mixin","aria-hidden":"true"},"#"),(0,s.Uk)(" Mixin")],-1),i=(0,s.Uk)("JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的"),t={href:"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem",target:"_blank",rel:"noopener noreferrer"},o=(0,s.Uk)("网状结构"),l=(0,s.Uk)("。"),c=(0,s.uE)('<p>但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。</p><p>各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面(interface)，这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口(method signature)，不定义实现，因此又被称为“抽象类”。凡是继承于 Interface 的方法，都必须自己定义实现，否则就会报错。这样就避免了多重继承的最大问题: 多个父类的同名方法的碰撞(naming collision)。</p><p>JavaScript 语言没有采用 Interface 的方案，而是通过代理(delegation)实现了从其他类引入方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var Enumerable_first = function () {\n  this.first = function () {\n    return this[0];\n  };\n};\n\nvar list = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];\nEnumerable_first.call(list); // explicit delegation\nlist.first(); // &quot;foo&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面代码中，<code>list</code> 是一个数组，本身并没有 <code>first</code> 方法。通过 <code>call</code> 方法，可以把 <code>Enumerable_first</code> 里面的方法，绑定到 <code>list</code>，从而 <code>list</code> 就具有 <code>first</code> 方法。这就叫做“代理”(delegation)，<code>list</code> 对象代理了 <code>Enumerable_first</code> 的 <code>first</code> 方法。</p><h2 id="含义" tabindex="-1"><a class="header-anchor" href="#含义" aria-hidden="true">#</a> 含义</h2><p>Mixin 这个名字来自于冰淇淋，在基本口味的冰淇淋上面混入其他口味，这就叫做 Mix-in。</p><p>它允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类。实质上是多重继承的一种解决方案，但是避免了多重继承的复杂性，而且有利于代码复用。</p><p>Mixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现。</p><p>子类通过在 <code>this</code> 对象上面绑定方法，达到多重继承的目的。</p><p>很多库提供了 Mixin 功能。下面以 Lodash 为例。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function vowels(string) {\n  return /[aeiou]/i.test(this.value);\n}\n\nvar obj = { value: &quot;hello&quot; };\n_.mixin(obj, { vowels: vowels });\nobj.vowels(); // true\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面代码通过 Lodash 库的 <code>_.mixin</code> 方法，让 <code>obj</code> 对象继承了 <code>vowels</code> 方法。</p><p>Underscore 的类似方法是 <code>_.extend</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var Person = function (fName, lName) {\n  this.firstName = fName;\n  this.lastName = lName;\n};\n\nvar sam = new Person(&quot;Sam&quot;, &quot;Lowry&quot;);\n\nvar NameMixin = {\n  fullName: function () {\n    return this.firstName + &quot; &quot; + this.lastName;\n  },\n  rename: function (first, last) {\n    this.firstName = first;\n    this.lastName = last;\n    return this;\n  },\n};\n_.extend(Person.prototype, NameMixin);\nsam.rename(&quot;Samwise&quot;, &quot;Gamgee&quot;);\nsam.fullName(); // &quot;Samwise Gamgee&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上面代码通过 <code>_.extend</code> 方法，在 <code>sam</code> 对象上面(准确说是它的原型对象 <code>Person.prototype</code> 上面)，混入了 <code>NameMixin</code> 类。</p><p><code>extend</code> 方法的实现非常简单。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function extend(destination, source) {\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      destination[k] = source[k];\n    }\n  }\n  return destination;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面代码将 <code>source</code> 对象的所有方法，添加到 <code>destination</code> 对象。</p><h2 id="trait" tabindex="-1"><a class="header-anchor" href="#trait" aria-hidden="true">#</a> Trait</h2><p>Trait 是另外一种多重继承的解决方案。它与 Mixin 很相似，但是有一些细微的差别。</p><ul><li>Mixin 可以包含状态(state)，Trait 不包含，即 Trait 里面的方法都是互不相干，可以线性包含的。比如，<code>Trait1</code> 包含方法 <code>A</code> 和 <code>B</code>，<code>Trait2</code> 继承了 <code>Trait1</code>，同时还包含一个自己的方法 <code>C</code>，实际上就等同于直接包含方法 <code>A</code>、<code>B</code>、<code>C</code>。</li><li>对于同名方法的碰撞，Mixin 包含了解决规则，Trait 则是报错。</li></ul>',22),p={},d=(0,a(82831).Z)(p,[["render",function(e,n){const a=(0,s.up)("ExternalLinkIcon");return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,(0,s._)("p",null,[i,(0,s._)("a",t,[o,(0,s.Wm)(a)]),l]),c],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},26684:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-5244cc12",path:"/code/language/js/es6/mixin.html",title:"Mixin",lang:"zh-CN",frontmatter:{icon:"merge",author:"阮一峰",category:["JavaScript"],copyright:'此部分博客采用 <a href="http://creativecommons.org/licenses/by-nc/4.0/" rel="noopener noreferrer" target="_blank">“保持署名—非商用”创意共享4.0许可证</a>',summary:"Mixin JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。 但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。 各种单一继承的编程语言，有不同的多重继承解决方案",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/es6/mixin.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"Mixin"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-12T05:50:30.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"阮一峰"}],["meta",{property:"article:modified_time",content:"2022-02-12T05:50:30.000Z"}]]},excerpt:"",headers:[{level:2,title:"含义",slug:"含义",children:[]},{level:2,title:"Trait",slug:"trait",children:[]}],git:{createdTime:1591204114e3,updatedTime:164464503e4,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:4}]},readingTime:{minutes:2.88,words:865},filePathRelative:"code/language/js/es6/mixin.md"}}}]);