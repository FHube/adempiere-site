"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[35267],{38916:(e,n,s)=>{s.r(n),s.d(n,{default:()=>A});var a=s(34086);const r=(0,a._)("p",null,"泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。",-1),l=(0,a.uE)('<h2 id="简单的例子" tabindex="-1"><a class="header-anchor" href="#简单的例子" aria-hidden="true">#</a> 简单的例子</h2><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function createArray(length: number, value: any): Array&lt;any&gt; {\n  let result = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\n\ncreateArray(3, &quot;x&quot;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div>',3),t=(0,a.Uk)("上例中，我们使用了"),p=(0,a.Uk)("之前提到过的数组泛型"),i=(0,a.Uk)("来定义返回值的类型。"),c=(0,a.uE)('<p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型:</p><p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p><p>这时候，泛型就派上用场了:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\n\ncreateArray&lt;string&gt;(3, &quot;x&quot;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\n\ncreateArray(3, &quot;x&quot;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="多个类型参数" tabindex="-1"><a class="header-anchor" href="#多个类型参数" aria-hidden="true">#</a> 多个类型参数</h2><p>定义泛型的时候，可以一次定义多个类型参数:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {\n  return [tuple[1], tuple[0]];\n}\n\nswap([7, &quot;seven&quot;]); // [&#39;seven&#39;, 7]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p><h2 id="泛型约束" tabindex="-1"><a class="header-anchor" href="#泛型约束" aria-hidden="true">#</a> 泛型约束</h2><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function loggingIdentity&lt;T&gt;(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// index.ts(2,19): error TS2339: Property &#39;length&#39; does not exist on type &#39;T&#39;.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p><p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\nloggingIdentity(7);\n\n// index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>多个类型参数之间也可以互相约束:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function copyFields&lt;T extends U, U&gt;(target: T, source: U): T {\n  for (let id in source) {\n    target[id] = (&lt;T&gt;source)[id];\n  }\n  return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyFields(x, { b: 10, d: 20 });\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p><h2 id="泛型接口" tabindex="-1"><a class="header-anchor" href="#泛型接口" aria-hidden="true">#</a> 泛型接口</h2>',24),u=(0,a.Uk)("之前学习过"),b=(0,a.Uk)("，可以使用接口的方式来定义一个函数需要符合的形状:"),d=(0,a.uE)('<div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string) {\n  return source.search(subString) !== -1;\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当然也可以使用含有泛型的接口来定义函数的形状:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface CreateArrayFunc {\n  &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;\n}\n\nlet createArray: CreateArrayFunc;\ncreateArray = function &lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n};\n\ncreateArray(3, &quot;x&quot;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>进一步，我们可以把泛型参数提前到接口名上:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface CreateArrayFunc&lt;T&gt; {\n  (length: number, value: T): Array&lt;T&gt;;\n}\n\nlet createArray: CreateArrayFunc&lt;any&gt;;\ncreateArray = function &lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n};\n\ncreateArray(3, &quot;x&quot;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p><h2 id="泛型类" tabindex="-1"><a class="header-anchor" href="#泛型类" aria-hidden="true">#</a> 泛型类</h2><p>与泛型接口类似，泛型也可以用于类的类型定义中:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>class GenericNumber&lt;T&gt; {\n  zeroValue: T;\n  add: (x: T, y: T) =&gt; T;\n}\n\nlet myGenericNumber = new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="泛型参数的默认类型" tabindex="-1"><a class="header-anchor" href="#泛型参数的默认类型" aria-hidden="true">#</a> 泛型参数的默认类型</h2><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {\n  let result: T[] = [];\n  for (let i = 0; i &lt; length; i++) {\n    result[i] = value;\n  }\n  return result;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',13),o={href:"http://www.typescriptlang.org/docs/handbook/generics.html",target:"_blank",rel:"noopener noreferrer"},m=(0,a.Uk)("Generics"),g=(0,a.Uk)("("),h={href:"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/generics.html",target:"_blank",rel:"noopener noreferrer"},y=(0,a.Uk)("中文版"),v=(0,a.Uk)(")"),T={href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults",target:"_blank",rel:"noopener noreferrer"},f=(0,a.Uk)("Generic parameter defaults"),x={},A=(0,s(82831).Z)(x,[["render",function(e,n){const s=(0,a.up)("RouterLink"),x=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a.kq)(" more "),l,(0,a._)("p",null,[t,(0,a.Wm)(s,{to:"/code/language/typescript/basics/type-of-array.html#%E6%95%B0%E7%BB%84%E6%B3%9B%E5%9E%8B"},{default:(0,a.w5)((()=>[p])),_:1}),i]),c,(0,a._)("p",null,[(0,a.Wm)(s,{to:"/code/language/typescript/basics/type-of-function.html#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"},{default:(0,a.w5)((()=>[u])),_:1}),b]),d,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",o,[m,(0,a.Wm)(x)]),g,(0,a._)("a",h,[y,(0,a.Wm)(x)]),v]),(0,a._)("li",null,[(0,a._)("a",T,[f,(0,a.Wm)(x)])])])],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}},35707:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-5edb8acc",path:"/code/language/typescript/advanced/generics.html",title:"泛型",lang:"zh-CN",frontmatter:{title:"泛型",icon:"generic",category:["TypeScript"],summary:"泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/typescript/advanced/generics.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"泛型"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-12T09:25:08.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-02-12T09:25:08.000Z"}]]},excerpt:"<p>泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n",headers:[{level:2,title:"简单的例子",slug:"简单的例子",children:[]},{level:2,title:"多个类型参数",slug:"多个类型参数",children:[]},{level:2,title:"泛型约束",slug:"泛型约束",children:[]},{level:2,title:"泛型接口",slug:"泛型接口",children:[]},{level:2,title:"泛型类",slug:"泛型类",children:[]},{level:2,title:"泛型参数的默认类型",slug:"泛型参数的默认类型",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644657908e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:3}]},readingTime:{minutes:4.1,words:1229},filePathRelative:"code/language/typescript/advanced/generics.md"}}}]);