"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[587],{76499:(n,e,a)=>{a.r(e),a.d(e,{default:()=>i});var s=a(34086);const r=(0,s._)("p",null,"通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。",-1),p=(0,s._)("p",null,"所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器: generator。",-1),l=(0,s.uE)('<p>要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个 generator:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; L = [x * x for x in range(10)]\n&gt;&gt;&gt; L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n&gt;&gt;&gt; g = (x * x for x in range(10))\n&gt;&gt;&gt; g\n&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>创建 <code>L</code> 和 <code>g</code> 的区别仅在于最外层的 <code>[]</code> 和 <code>()</code>，L 是一个 list，而 g 是一个 generator。</p><p>我们可以直接打印出 list 的每一个元素，但我们怎么打印出 generator 的每一个元素呢?</p><p>如果要一个一个打印出来，可以通过 <code>next()</code> 函数获得 generator 的下一个返回值:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; next(g)\n0\n&gt;&gt;&gt; next(g)\n1\n&gt;&gt;&gt; next(g)\n4\n&gt;&gt;&gt; next(g)\n9\n&gt;&gt;&gt; next(g)\n16\n&gt;&gt;&gt; next(g)\n25\n&gt;&gt;&gt; next(g)\n36\n&gt;&gt;&gt; next(g)\n49\n&gt;&gt;&gt; next(g)\n64\n&gt;&gt;&gt; next(g)\n81\n&gt;&gt;&gt; next(g)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nStopIteration\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>我们讲过，generator 保存的是算法，每次调用 <code>next(g)</code>，就计算出 <code>g</code> 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 <code>StopIteration</code> 的错误。</p><p>当然，上面这种不断调用 <code>next(g)</code> 实在是太变态了，正确的方法是使用 for 循环，因为 generator 也是可迭代对象:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; g = (x * x for x in range(10))\n&gt;&gt;&gt; for n in g:\n...     print(n)\n...\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>所以，我们创建了一个 generator 后，基本上永远不会调用 <code>next()</code>，而是通过 for 循环来迭代它，并且不需要关心 <code>StopIteration</code> 的错误。</p><p>Generator 非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列(Fibonacci)，除第一个和第二个数外，任意一个数都可由前两个数相加得到:</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def fib(max):\n    n, a, b = 0, 0, 1\n    while n &lt; max:\n        print(b)\n        a, b = b, a + b\n        n = n + 1\n    return &#39;done&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注意，赋值语句:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>a, b = b, a + b\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>相当于:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>t = (b, a + b) # t是一个tuple\na = t[0]\nb = t[1]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但不必显式写出临时变量 <code>t</code> 就可以赋值。</p><p>上面的函数可以输出斐波那契数列的前 N 个数:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; fib(6)\n1\n1\n2\n3\n5\n8\n&#39;done&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>仔细观察，可以看出，<code>fib</code> 函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似 generator。</p><p>也就是说，上面的函数和 generator 仅一步之遥。要把 fib 函数变成 generator，只需要把 <code>print(b)</code> 改为 <code>yield b</code> 就可以了:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def fib(max):\n    n, a, b = 0, 0, 1\n    while n &lt; max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return &#39;done&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这就是定义 generator 的另一种方法。如果一个函数定义中包含 <code>yield</code> 关键字，那么这个函数就不再是一个普通函数，而是一个 generator:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f = fib(6)\n&gt;&gt;&gt; f\n&lt;generator object fib at 0x104feaaa0&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里，最难理解的就是 generator 和函数的执行流程不一样。函数是顺序执行，遇到 <code>return</code> 语句或者最后一行函数语句就返回。而变成 generator 的函数，在每次调用 <code>next()</code> 的时候执行，遇到 <code>yield</code> 语句返回，再次执行时从上次返回的 <code>yield</code> 语句处继续执行。</p><p>举个简单的例子，定义一个 generator，依次返回数字 1，3，5:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def odd():\n    print(&#39;step 1&#39;)\n    yield 1\n    print(&#39;step 2&#39;)\n    yield(3)\n    print(&#39;step 3&#39;)\n    yield(5)\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>调用该 generator 时，首先要生成一个 generator 对象，然后用 <code>next()</code> 函数不断获得下一个返回值:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; o = odd()\n&gt;&gt;&gt; next(o)\nstep 1\n1\n&gt;&gt;&gt; next(o)\nstep 2\n3\n&gt;&gt;&gt; next(o)\nstep 3\n5\n&gt;&gt;&gt; next(o)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nStopIteration\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，<code>odd</code> 不是普通函数，而是 generator，在执行过程中，遇到 <code>yield</code> 就中断，下次又继续执行。执行 3 次 <code>yield</code> 后，已经没有 <code>yield</code> 可以执行了，所以，第 4 次调用 <code>next(o)</code> 就报错。</p><p>回到 fib 的例子，我们在循环过程中不断调用 <code>yield</code>，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p><p>同样的，把函数改成 generator 后，我们基本上从来不会用 <code>next()</code> 来获取下一个返回值，而是直接使用 for 循环来迭代:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; for n in fib(6):\n...     print(n)\n...\n1\n1\n2\n3\n5\n8\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是用 for 循环调用 generator 时，发现拿不到 generator 的 <code>return</code> 语句的返回值。如果想要拿到返回值，必须捕获 <code>StopIteration</code> 错误，返回值包含在 <code>StopIteration</code> 的 value 中:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; g = fib(6)\n&gt;&gt;&gt; while True:\n...     try:\n...         x = next(g)\n...         print(&#39;g:&#39;, x)\n...     except StopIteration as e:\n...         print(&#39;Generator return value:&#39;, e.value)\n...         break\n...\ng: 1\ng: 1\ng: 2\ng: 3\ng: 5\ng: 8\nGenerator return value: done\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>关于如何捕获错误，后面的错误处理还会详细讲解。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>Generator 是非常强大的工具，在 Python 中，可以简单地把列表生成式改成 generator，也可以通过函数实现复杂逻辑的 generator。</p><p>要理解 generator 的工作原理，它是在 for 循环的过程中不断计算出下一个元素，并在适当的条件结束 for 循环。对于函数改成的 generator 来说，遇到 <code>return</code> 语句或者执行到函数体最后一行语句，就是结束 generator 的指令，for 循环随之结束。</p><p>请注意区分普通函数和 generator 函数，普通函数调用直接返回结果:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; r = abs(6)\n&gt;&gt;&gt; r\n6\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Generator 函数的“调用”实际返回一个 generator 对象:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; g = fib(6)\n&gt;&gt;&gt; g\n&lt;generator object fib at 0x1022ef948&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',46),t={},i=(0,a(82831).Z)(t,[["render",function(n,e){return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,p,(0,s.kq)(" more "),l],64)}]])},82831:(n,e)=>{e.Z=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},51402:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-0d6dbef8",path:"/code/language/python/advance/generator.html",title:"生成器",lang:"zh-CN",frontmatter:{title:"生成器",icon:"cycle",author:"廖雪峰",date:"2020-05-29T00:00:00.000Z",category:["Python"],summary:"通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器: generator。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/python/advance/generator.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"生成器"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"廖雪峰"}],["meta",{property:"article:published_time",content:"2020-05-29T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>\n<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢? 这样就不必创建完整的 list，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器: generator。</p>\n",headers:[{level:2,title:"小结",slug:"小结",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:6},{name:"Mister-Hope",email:"zhangbowang1998@gmail.com",commits:1}]},readingTime:{minutes:5.46,words:1638},filePathRelative:"code/language/python/advance/generator.md"}}}]);