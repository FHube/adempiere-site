"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[75828],{29148:(n,e,s)=>{s.r(e),s.d(e,{default:()=>y});var a=s(34086);const r=(0,a.Uk)("之前学习过"),l=(0,a.Uk)("，接口(Interfaces)可以用于对「对象的形状(Shape)」进行描述。"),t=(0,a._)("p",null,"这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。",-1),p=(0,a.uE)('<h2 id="类实现接口" tabindex="-1"><a class="header-anchor" href="#类实现接口" aria-hidden="true">#</a> 类实现接口</h2><p>实现(implements)是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口(interfaces)，用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Alarm {\n  alert();\n}\n\nclass Door {}\n\nclass SecurityDoor extends Door implements Alarm {\n  alert() {\n    console.log(&quot;SecurityDoor alert&quot;);\n  }\n}\n\nclass Car implements Alarm {\n  alert() {\n    console.log(&quot;Car alert&quot;);\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>一个类可以实现多个接口:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Alarm {\n  alert();\n}\n\ninterface Light {\n  lightOn();\n  lightOff();\n}\n\nclass Car implements Alarm, Light {\n  alert() {\n    console.log(&quot;Car alert&quot;);\n  }\n  lightOn() {\n    console.log(&quot;Car light on&quot;);\n  }\n  lightOff() {\n    console.log(&quot;Car light off&quot;);\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p><h2 id="接口继承接口" tabindex="-1"><a class="header-anchor" href="#接口继承接口" aria-hidden="true">#</a> 接口继承接口</h2><p>接口与接口之间可以是继承关系:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Alarm {\n  alert();\n}\n\ninterface LightableAlarm extends Alarm {\n  lightOn();\n  lightOff();\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code>。</p><h2 id="接口继承类" tabindex="-1"><a class="header-anchor" href="#接口继承类" aria-hidden="true">#</a> 接口继承类</h2><p>接口也可以继承类:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>class Point {\n  x: number;\n  y: number;\n}\n\ninterface Point3d extends Point {\n  z: number;\n}\n\nlet point3d: Point3d = { x: 1, y: 2, z: 3 };\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="混合类型" tabindex="-1"><a class="header-anchor" href="#混合类型" aria-hidden="true">#</a> 混合类型</h2>',15),i=(0,a.Uk)("之前学习过"),c=(0,a.Uk)("，可以使用接口的方式来定义一个函数需要符合的形状:"),b=(0,a.uE)('<div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string) {\n  return source.search(subString) !== -1;\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>有时候，一个函数还可以有自己的属性和方法:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = &lt;Counter&gt;function (start: number) {};\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',4),u={href:"http://www.typescriptlang.org/docs/handbook/interfaces.html",target:"_blank",rel:"noopener noreferrer"},o=(0,a.Uk)("Interfaces"),m=(0,a.Uk)("("),d={href:"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("中文版"),h=(0,a.Uk)(")"),f={},y=(0,s(82831).Z)(f,[["render",function(n,e){const s=(0,a.up)("RouterLink"),f=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("p",null,[(0,a.Wm)(s,{to:"/code/language/typescript/basics/type-of-object-interfaces.html"},{default:(0,a.w5)((()=>[r])),_:1}),l]),t,(0,a.kq)(" more "),p,(0,a._)("p",null,[(0,a.Wm)(s,{to:"/code/language/typescript/basics/type-of-function.html#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"},{default:(0,a.w5)((()=>[i])),_:1}),c]),b,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",u,[o,(0,a.Wm)(f)]),m,(0,a._)("a",d,[g,(0,a.Wm)(f)]),h])])],64)}]])},82831:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},13154:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-f0d4733a",path:"/code/language/typescript/advanced/class-and-interfaces.html",title:"类与接口",lang:"zh-CN",frontmatter:{title:"类与接口",icon:"api",category:["TypeScript"],summary:"之前学习过，接口(Interfaces)可以用于对「对象的形状(Shape)」进行描述。\n这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/typescript/advanced/class-and-interfaces.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"类与接口"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-12T09:25:08.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2022-02-12T09:25:08.000Z"}]]},excerpt:'<p><RouterLink to="/code/language/typescript/basics/type-of-object-interfaces.html">之前学习过</RouterLink>，接口(Interfaces)可以用于对「对象的形状(Shape)」进行描述。</p>\n<p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p>\n',headers:[{level:2,title:"类实现接口",slug:"类实现接口",children:[]},{level:2,title:"接口继承接口",slug:"接口继承接口",children:[]},{level:2,title:"接口继承类",slug:"接口继承类",children:[]},{level:2,title:"混合类型",slug:"混合类型",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644657908e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:3}]},readingTime:{minutes:1.83,words:549},filePathRelative:"code/language/typescript/advanced/class-and-interfaces.md"}}}]);