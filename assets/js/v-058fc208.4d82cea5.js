"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[79296],{42618:(e,n,a)=>{a.r(n),a.d(n,{default:()=>t});var s=a(34086);const r=(0,s._)("p",null,"本章对 JavaScript 的可遍历数据结构及如何遍历做一些介绍。",-1),l=(0,s.uE)('<h2 id="iterable" tabindex="-1"><a class="header-anchor" href="#iterable" aria-hidden="true">#</a> iterable</h2><p>遍历 Array 可以采用下标循环，遍历 Map 和 Set 就无法使用下标。为了统一集合类型，ES6 标准引入了新的 <code>iterable</code> 类型，Array、Map 和 Set 都属于 <code>iterable</code> 类型。</p><p>具有 <code>iterable</code> 类型的集合可以通过新的 <code>for ... of</code> 循环来遍历。</p><p><code>for ... of</code> 循环是 ES6 引入的新的语法，用 <code>for ... of</code> 循环遍历集合，用法如下:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const a = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\nconst s = new Set([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]);\nconst m = new Map([\n  [1, &quot;x&quot;],\n  [2, &quot;y&quot;],\n  [3, &quot;z&quot;],\n]);\n\nfor (let x of a) {\n  // 遍历Array\n  console.log(x);\n}\nfor (let x of s) {\n  // 遍历Set\n  console.log(x);\n}\nfor (let x of m) {\n  // 遍历Map\n  console.log(x[0] + &quot;=&quot; + x[1]);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>您可能会有疑问，<code>for ... of</code> 循环和 <code>for ... in</code> 循环有何区别?</p><p><code>for ... in</code> 循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个 Array 数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p><p>当我们手动给 Array 对象添加了额外的属性后，<code>for ... in</code> 循环将带来意想不到的意外效果:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const a = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\n\na.name = &quot;Hello&quot;;\nfor (let x in a) {\n  console.log(x); // &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;name&#39;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p><code>for ... in</code> 循环将把 name 包括在内，但 Array 的 <code>length</code> 属性却不包括在内。</p></div><p><code>for ... of</code> 循环则完全修复了这些问题，它只循环集合本身的元素:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const a = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\n\na.name = &quot;Hello&quot;;\nfor (let x of a) {\n  console.log(x); // &#39;A&#39;, &#39;B&#39;, &#39;C&#39;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这就是为什么要引入新的 <code>for ... of</code> 循环。</p><p>然而，更好的方式是直接使用 <code>iterable</code> 内置的 <code>forEach</code> 方法，它接收一个函数，每次迭代就自动回调该函数。以 Array 为例:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\nconst a = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\n\na.forEach(function (element, index, array) {\n  // element: 指向当前元素的值\n  // index: 指向当前索引\n  // array: 指向Array对象本身\n  console.log(element + &quot;, index = &quot; + index);\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">注意</p><p><code>forEach()</code> 方法是 ES5.1 标准引入的，您需要测试浏览器是否支持 (IE says No)。</p></div><p>Set 与 Array 类似，但 Set 没有索引，因此回调函数的前两个参数都是元素本身:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const s = new Set([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]);\n\ns.forEach(function (element, sameElement, set) {\n  console.log(element);\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Map 的回调函数参数依次为 <code>value</code>、<code>key</code> 和 <code>map</code> 本身:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const m = new Map([\n  [1, &quot;x&quot;],\n  [2, &quot;y&quot;],\n  [3, &quot;z&quot;],\n]);\n\nm.forEach(function (value, key, map) {\n  console.log(value);\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果对某些参数不感兴趣，由于 JavaScript 的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得 Array 的 <code>element</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const a = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\n\na.forEach(function (element) {\n  console.log(element);\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',22),o={},t=(0,a(82831).Z)(o,[["render",function(e,n){return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,(0,s.kq)(" more "),l],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},91216:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-058fc208",path:"/code/language/js/guide/iterable.html",title:"遍历",lang:"zh-CN",frontmatter:{title:"遍历",icon:"refresh",date:"2019-09-19T00:00:00.000Z",category:["JavaScript"],summary:"本章对 JavaScript 的可遍历数据结构及如何遍历做一些介绍。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/guide/iterable.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"遍历"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:published_time",content:"2019-09-19T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"<p>本章对 JavaScript 的可遍历数据结构及如何遍历做一些介绍。</p>\n",headers:[{level:2,title:"iterable",slug:"iterable",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:5}]},readingTime:{minutes:2.24,words:672},filePathRelative:"code/language/js/guide/iterable.md"}}}]);