"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[66619],{40610:(e,n,s)=>{s.r(n),s.d(n,{default:()=>E});var t=s(34086);const r=(0,t._)("p",null,"类型断言(Type Assertion)可以用来手动指定一个值的类型。",-1),a=(0,t.uE)('<h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h2><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>&lt;类型&gt;值;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>值 as 类型;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在 tsx 语法(React 的 jsx 语法的 ts 版)中必须用后一种。</p><h2 id="例子-将一个联合类型的变量指定为一个更加具体的类型" tabindex="-1"><a class="header-anchor" href="#例子-将一个联合类型的变量指定为一个更加具体的类型" aria-hidden="true">#</a> 例子: 将一个联合类型的变量指定为一个更加具体的类型</h2>',6),i=(0,t.Uk)("之前提到过"),p=(0,t.Uk)("，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们"),l=(0,t._)("strong",null,"只能访问此联合类型的所有类型里共有的属性或方法",-1),o=(0,t.Uk)(":"),c=(0,t.uE)('<div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function getLength(something: string | number): number {\n  return something.length;\n}\n\n// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function getLength(something: string | number): number {\n  if (something.length) {\n    return something.length;\n  } else {\n    return something.toString().length;\n  }\n}\n\n// index.ts(2,19): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n// index.ts(3,26): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上例中，获取 <code>something.length</code> 的时候会报错。</p><p>此时可以使用类型断言，将 <code>something</code> 断言成 <code>string</code>:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function getLength(something: string | number): number {\n  if ((&lt;string&gt;something).length) {\n    return (&lt;string&gt;something).length;\n  } else {\n    return something.toString().length;\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>类型断言的用法如上，在需要断言的变量前加上 <code>&lt;Type&gt;</code> 即可。</p><p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong>:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>function toBoolean(something: string | number): boolean {\n  return &lt;boolean&gt;something;\n}\n\n// index.ts(2,10): error TS2352: Type &#39;string | number&#39; cannot be converted to type &#39;boolean&#39;.\n//   Type &#39;number&#39; is not comparable to type &#39;boolean&#39;.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',10),d={href:"https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html",target:"_blank",rel:"noopener noreferrer"},u=(0,t.Uk)("TypeScript Deep Dive / Type Assertion"),b={href:"http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types",target:"_blank",rel:"noopener noreferrer"},g=(0,t.Uk)("Advanced Types # Type Guards and Differentiating Types"),m=(0,t.Uk)("("),h={href:"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced%20Types.html#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%E4%B8%8E%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B(type-guards-and-differentiating-types)",target:"_blank",rel:"noopener noreferrer"},y=(0,t.Uk)("中文版"),v=(0,t.Uk)(")"),f={},E=(0,s(82831).Z)(f,[["render",function(e,n){const s=(0,t.up)("RouterLink"),f=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)(t.HY,null,[r,(0,t.kq)(" more "),a,(0,t._)("p",null,[(0,t.Wm)(s,{to:"/code/language/typescript/basics/union-types.html#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95"},{default:(0,t.w5)((()=>[i])),_:1}),p,l,o]),c,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t._)("a",d,[u,(0,t.Wm)(f)])]),(0,t._)("li",null,[(0,t._)("a",b,[g,(0,t.Wm)(f)]),m,(0,t._)("a",h,[y,(0,t.Wm)(f)]),v])])],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,t]of n)s[e]=t;return s}},56078:(e,n,s)=>{s.r(n),s.d(n,{data:()=>t});const t={key:"v-cc37e3c8",path:"/code/language/typescript/basics/type-assertion.html",title:"类型断言",lang:"zh-CN",frontmatter:{title:"类型断言",icon:"boolean",category:["TypeScript"],summary:"类型断言(Type Assertion)可以用来手动指定一个值的类型。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/typescript/basics/type-assertion.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"类型断言"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2020-06-03T17:08:34.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2020-06-03T17:08:34.000Z"}]]},excerpt:"<p>类型断言(Type Assertion)可以用来手动指定一个值的类型。</p>\n",headers:[{level:2,title:"语法",slug:"语法",children:[]},{level:2,title:"例子: 将一个联合类型的变量指定为一个更加具体的类型",slug:"例子-将一个联合类型的变量指定为一个更加具体的类型",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],git:{createdTime:1591204114e3,updatedTime:1591204114e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:1}]},readingTime:{minutes:1.56,words:467},filePathRelative:"code/language/typescript/basics/type-assertion.md"}}}]);