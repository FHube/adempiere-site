"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[90456],{92308:(e,n,s)=>{s.r(n),s.d(n,{default:()=>R});var r=s(34086);const a=(0,r._)("div",{class:"custom-container tip"},[(0,r._)("p",{class:"custom-container-title"},"提示"),(0,r._)("p",null,"此部分在初步学习小程序的时候直接略过即可。")],-1),t=(0,r._)("h2",{id:"wxml-节点信息",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#wxml-节点信息","aria-hidden":"true"},"#"),(0,r.Uk)(" WXML 节点信息")],-1),l={href:"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html",target:"_blank",rel:"noopener noreferrer"},i=(0,r.Uk)("节点信息查询 API"),c=(0,r.Uk)(" 可以用于获取节点属性、样式、在界面上的位置等信息。"),o=(0,r._)("p",null,"最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。",-1),p={class:"custom-block details"},u=(0,r.uE)('<summary>代码示例</summary><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const query = wx.createSelectorQuery();\nquery.select(&quot;#the-id&quot;).boundingClientRect(function (res) {\n  res.top; // #the-id 节点的上边界坐标(相对于显示区域)\n});\nquery.selectViewport().scrollOffset(function (res) {\n  res.scrollTop; // 显示区域的竖直滚动位置\n});\n\nquery.exec();\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div>',2),m=(0,r.Uk)("上述示例中， "),d=(0,r._)("code",null,"#the-id",-1),b=(0,r.Uk)(" 是一个节点选择器，与 CSS 的选择器相近但略有区别，请参见 "),h={href:"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html",target:"_blank",rel:"noopener noreferrer"},g=(0,r.Uk)("SelectorQuery.select"),v=(0,r.Uk)(" 的相关说明。"),w=(0,r._)("div",{class:"custom-container tip"},[(0,r._)("p",{class:"custom-container-title"},"提示"),(0,r._)("p",null,[(0,r.Uk)("在自定义组件或包含自定义组件的页面中，推荐使用 "),(0,r._)("code",null,"this.createSelectorQuery"),(0,r.Uk)(" 来代替 "),(0,r._)("code",null,"wx.createSelectorQuery"),(0,r.Uk)(" ，这样可以确保在正确的范围内选择节点。")])],-1),_=(0,r._)("h2",{id:"wxml-节点布局相交状态",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#wxml-节点布局相交状态","aria-hidden":"true"},"#"),(0,r.Uk)(" WXML 节点布局相交状态")],-1),x={href:"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createIntersectionObserver.html",target:"_blank",rel:"noopener noreferrer"},y=(0,r.Uk)("节点布局相交状态 API"),f=(0,r.Uk)(" 可用于监听两个或多个组件节点在布局位置上的相交状态。这一组 API 常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。"),k=(0,r.uE)('<p>这一组 API 涉及的主要概念如下。</p><ul><li>参照节点: 监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的 <strong>交集</strong> 作为参照区域。页面显示区域也可作为参照区域之一。</li><li>目标节点: 监听的目标，默认只能是一个节点(使用 selectAll 选项时，可以同时监听多个节点)。</li><li>相交区域: 目标节点的布局区域与参照区域的相交区域。</li><li>相交比例: 相交区域占参照区域的比例。</li><li>阈值: 相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。</li></ul><details class="custom-block details"><summary>代码示例</summary><p>以下示例代码可以在目标节点(用选择器 <code>.target-class</code> 指定)每次进入或离开页面显示区域时，触发回调函数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Page({\n  onLoad() {\n    wx.createIntersectionObserver()\n      .relativeToViewport()\n      .observe(&quot;.target-class&quot;, (res) =&gt; {\n        res.id; // 目标节点 id\n        res.dataset; // 目标节点 dataset\n        res.intersectionRatio; // 相交区域占目标节点的布局区域的比例\n        res.intersectionRect; // 相交区域\n        res.intersectionRect.left; // 相交区域的左边界坐标\n        res.intersectionRect.top; // 相交区域的上边界坐标\n        res.intersectionRect.width; // 相交区域的宽度\n        res.intersectionRect.height; // 相交区域的高度\n      });\n  },\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>以下示例代码可以在目标节点(用选择器 <code>.target-class</code> 指定)与参照节点(用选择器 <code>.relative-class</code> 指定)在页面显示区域内相交或相离，且相交或相离程度达到目标节点布局区域的 20%和 50%时，触发回调函数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Page({\n  onLoad() {\n    wx.createIntersectionObserver(this, {\n      thresholds: [0.2, 0.5],\n    })\n      .relativeTo(&quot;.relative-class&quot;)\n      .relativeToViewport()\n      .observe(&quot;.target-class&quot;, (res) =&gt; {\n        res.intersectionRatio; // 相交区域占目标节点的布局区域的比例\n        res.intersectionRect; // 相交区域\n        res.intersectionRect.left; // 相交区域的左边界坐标\n        res.intersectionRect.top; // 相交区域的上边界坐标\n        res.intersectionRect.width; // 相交区域的宽度\n        res.intersectionRect.height; // 相交区域的高度\n      });\n  },\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></details><div class="custom-container warning"><p class="custom-container-title">注意</p><p>与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是“布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏(如遇祖先节点中 overflow 样式为 <code>hidden</code> 的节点)或遮盖(如遇 <code>fixed</code> 定位的节点)。</p></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>在自定义组件或包含自定义组件的页面中，推荐使用 <code>this.createIntersectionObserver</code> 来代替 <code>wx.createIntersectionObserver</code> ，这样可以确保在正确的范围内选择节点。</p></div>',5),q={},R=(0,s(82831).Z)(q,[["render",function(e,n){const s=(0,r.up)("ExternalLinkIcon");return(0,r.wg)(),(0,r.iD)(r.HY,null,[a,t,(0,r._)("p",null,[(0,r._)("a",l,[i,(0,r.Wm)(s)]),c]),o,(0,r._)("details",p,[u,(0,r._)("p",null,[m,d,b,(0,r._)("a",h,[g,(0,r.Wm)(s)]),v])]),w,_,(0,r._)("p",null,[(0,r._)("a",x,[y,(0,r.Wm)(s)]),f]),k],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,r]of n)s[e]=r;return s}},84667:(e,n,s)=>{s.r(n),s.d(n,{data:()=>r});const r={key:"v-b7241244",path:"/code/mini-app/guide/view/selector.html",title:"获取界面上的节点信息",lang:"zh-CN",frontmatter:{title:"获取界面上的节点信息",icon:"select",category:["小程序"],summary:"此部分在初步学习小程序的时候直接略过即可。 WXML 节点信息 节点信息查询 API 可以用于获取节点属性、样式、在界面上的位置等信息。 最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。 代码示例 上述示例中， #the-id 是一个节点选择器，与 CSS 的选择器相近但略有区别，请参见 SelectorQuery.select 的相",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/mini-app/guide/view/selector.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"获取界面上的节点信息"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2021-01-19T13:09:25.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2021-01-19T13:09:25.000Z"}]]},excerpt:"",headers:[{level:2,title:"WXML 节点信息",slug:"wxml-节点信息",children:[]},{level:2,title:"WXML 节点布局相交状态",slug:"wxml-节点布局相交状态",children:[]}],git:{createdTime:1611033126e3,updatedTime:1611061765e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:4}]},readingTime:{minutes:3.08,words:923},filePathRelative:"code/mini-app/guide/view/selector.md"}}}]);