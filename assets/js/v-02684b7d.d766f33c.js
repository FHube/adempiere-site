"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[76764],{81207:(n,s,e)=>{e.r(s),e.d(s,{default:()=>c});const a=(0,e(34086).uE)('<h2 id="函数作为返回值" tabindex="-1"><a class="header-anchor" href="#函数作为返回值" aria-hidden="true">#</a> 函数作为返回值</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>我们来实现一个对 Array 的求和。通常情况下，求和的函数是这样定义的:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const sum = (arr) =&gt; arr.reduce((x, y) =&gt; x + y);\n\nsum([1, 2, 3, 4, 5]); // 15\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>变量 <code>sum</code> 等同于:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function sum(arr) {\n  return arr.reduce(function (x, y) {\n    return x + y;\n  });\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></div><p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办? 可以不返回求和的结果，而是返回求和的函数!</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const lazy_sum = (arr) =&gt; () =&gt; arr.reduce((x, y) =&gt; x + y);\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>上面的 <code>lazy_sum()</code> 等同于:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function lazy_sum(arr) {\n  const sum = function () {\n    return arr.reduce(function (x, y) {\n      return x + y;\n    });\n  };\n\n  return sum;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div><p>当我们调用 <code>lazy_sum()</code> 时，返回的并不是求和结果，而是求和函数:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>调用函数 f 时，才真正计算求和的结果:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>f(); // 15\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>上面的例子也很好的证明了箭头函数的简洁性。</p><p>随着开发的深入，应当逐渐熟悉使用箭头函数来写出更简洁的写法。</p></div><p>在这个例子中，我们在函数 <code>lazy_sum</code> 中又定义了函数 <code>sum</code>，并且，内部函数 <code>sum</code> 可以引用外部函数 <code>lazy_sum</code> 的参数和局部变量，当 <code>lazy_sum</code> 返回函数 <code>sum</code> 时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用 <code>lazy_sum()</code> 时，每次调用都会返回一个新的函数，即使传入相同的参数:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const f1 = lazy_sum([1, 2, 3, 4, 5]);\nconst f2 = lazy_sum([1, 2, 3, 4, 5]);\n\nf1 === f2; // false\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>f1()</code> 和 <code>f2()</code> 的调用结果互不影响。</p><h2 id="闭包注意事项" tabindex="-1"><a class="header-anchor" href="#闭包注意事项" aria-hidden="true">#</a> 闭包注意事项</h2><p>注意到返回的函数在其定义内部引用了局部变量 <code>arr</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 <code>f()</code> 才执行。我们来看一个例子:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function count() {\n  const arr = new Array(3);\n\n  for (let i = 1; i &lt;= arr.length; i++) arr.push(() =&gt; i * i);\n\n  return arr;\n}\n\nconst results = count();\nconst f1 = results[0];\nconst f2 = results[1];\nconst f3 = results[2];\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的 3 个函数都添加到一个 Array 中返回了。</p><p>您可能认为调用 <code>f1()</code>，<code>f2()</code> 和 <code>f3()</code> 结果应该是 <code>1，4，9</code>，但实际结果是:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>f1(); // 16\nf2(); // 16\nf3(); // 16\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>全部都是 16! 原因就在于返回的函数引用了变量 <code>i</code>，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 i 已经变成了 <code>4</code>，因此最终结果为 <code>16</code>。</p><p>返回闭包时牢记的一点就是: 返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><p>如果一定要引用循环变量怎么办? 方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function count() {\n  const arr = [];\n  for (let i = 1; i &lt;= 3; i++)\n    arr.push(\n      (\n        (n) =&gt; () =&gt;\n          n * n\n      )(i)\n    );\n\n  return arr;\n}\n\nconst results = count();\nconst f1 = results[0];\nconst f2 = results[1];\nconst f3 = results[2];\n\nf1(); // 1\nf2(); // 4\nf3(); // 9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>((x) =&gt; x * x)(3); // 9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>理论上讲，创建一个匿名函数并立刻执行可以这么写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function (x) { return x * x } (3);\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但是由于 JavaScript 语法解析的问题，会报 SyntaxError 错误，因此需要用括号把整个函数定义括起来:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>(function (x) {\n  return x * x;\n})(3);\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>或者使用箭头函数的写法:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>((x) =&gt; x * x)(3); // 9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>(x =&gt; {\n  ...\n})(...);\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗?</p><p>当然不是! 闭包有非常强大的功能。举个栗子:</p><p>在面向对象的程序设计语言里，比如 Java 和 C++，要在对象内部封装一个私有变量，可以用 <code>private</code> 修饰一个成员变量。</p><p>在没有 class 机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用 JavaScript 创建一个计数器:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\n\nconst create_counter = (counter = 0) =&gt; ({\n  inc: () =&gt; {\n    counter += 1;\n    return counter;\n  },\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">最后的提示</p><p>上面的函数等效于:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\n\nfunction create_counter(initial) {\n  let x = initial || 0;\n  return {\n    inc() {\n      x += 1;\n\n      return x;\n    },\n  };\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这是最后一个提示了。</p><p>之后，略微复杂的箭头函数将不再包含正常写法的版本，如果理解起来吃力，请多加阅读箭头函数章节并针对以上案例充分理解。</p></div><p>它用起来像这样:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const c1 = create_counter();\nc1.inc(); // 1\nc1.inc(); // 2\nc1.inc(); // 3\n\nconst c2 = create_counter(10);\nc2.inc(); // 11\nc2.inc(); // 12\nc2.inc(); // 13\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量 <code>x</code>，并且，从外部代码根本无法访问到变量 <code>x</code>。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p><p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算 <code>xy</code> 可以用 <code>Math.pow(x, y)</code> 函数，不过考虑到经常计算 <code>x2</code> 或 <code>x3</code>，我们可以利用闭包创建新的函数 <code>pow2</code> 和 <code>pow3</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\n\nconst make_pow = (n) =&gt; (x) =&gt; Math.pow(x, n);\n// 创建两个新函数:\nconst pow2 = make_pow(2);\nconst pow3 = make_pow(3);\n\nconsole.log(pow2(5)); // 25\nconsole.log(pow3(7)); // 343\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">脑洞大开</p><p>很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 这些数字和 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>这些符号。</p><p>JavaScript 支持函数，所以可以用 JavaScript 用函数来写这些计算。来试试:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\n\n// 定义数字0:\nconst zero = () =&gt; (x) =&gt; x;\n\n// 定义数字1:\nconst one = (f) =&gt; (x) =&gt; f(x);\n\n// 定义加法:\nconst add = (n, m) =&gt; (f) =&gt; (x) =&gt; m(f)(n(f)(x));\n\n// 计算数字2 = 1 + 1:\nconst two = add(one, one);\n\n// 计算数字3 = 1 + 2:\nconst three = add(one, two);\n\n// 计算数字5 = 2 + 3:\nconst five = add(two, three);\n\n// 您说它是 3 就是 3，您说它是 5 就是 5，您怎么证明?\n\n// 呵呵，看这里:\n\n// 给 3 传一个函数,会打印 3 次:\nthree(() =&gt; console.log(&quot;print 3 times&quot;))();\n\n// 给 5 传一个函数,会打印 5 次:\nfive(() =&gt; console.log(&quot;print 5 times&quot;))();\n\n// 继续接着玩一会...\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div></div>',50),r={},c=(0,e(82831).Z)(r,[["render",function(n,s){return a}]])},82831:(n,s)=>{s.Z=(n,s)=>{const e=n.__vccOpts||n;for(const[n,a]of s)e[n]=a;return e}},44360:(n,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-02684b7d",path:"/code/language/js/function/closure.html",title:"闭包",lang:"zh-CN",frontmatter:{title:"闭包",icon:"lock",date:"2019-10-07T00:00:00.000Z",category:["JavaScript"],summary:"函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个对 Array 的求和。通常情况下，求和的函数是这样定义的: 变量 sum 等同于: 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办? 可以不返回求和的结果，而是返回求和的函数! 上面的 lazy_sum() 等同于: 当我们调用 lazy_s",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/function/closure.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"闭包"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:published_time",content:"2019-10-07T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"",headers:[{level:2,title:"函数作为返回值",slug:"函数作为返回值",children:[]},{level:2,title:"闭包注意事项",slug:"闭包注意事项",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:8}]},readingTime:{minutes:5.59,words:1676},filePathRelative:"code/language/js/function/closure.md"}}}]);