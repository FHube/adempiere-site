"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[46788],{86843:(e,n,s)=>{s.r(n),s.d(n,{default:()=>v});var a=s(34086);const c=(0,a._)("p",null,"本章介绍 Bash 脚本的条件判断语法。",-1),l=(0,a.uE)('<h2 id="if-结构" tabindex="-1"><a class="header-anchor" href="#if-结构" aria-hidden="true">#</a> if 结构</h2><p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if commands; then\n  commands\n[elif commands; then\n  commands...]\n[else\n  commands]\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p><p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if test $USER = &quot;foo&quot;; then\n  echo &quot;Hello foo.&quot;\nelse\n  echo &quot;You are not foo.&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p><p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if true\nthen\n  echo &#39;hello world&#39;\nfi\n\nif false\nthen\n  echo &#39;it is false&#39; # 本行不会执行\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p><p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if true; then echo &#39;hello world&#39;; fi\nhello world\n\n$ if false; then echo &quot;It&#39;s true.&quot;; fi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if echo &#39;hi&#39;; then echo &#39;hello world&#39;; fi\nhi\nhello world\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo &#39;hi&#39;</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p><p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if false; true; then echo &#39;hello world&#39;; fi\nhello world\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p><p><code>elif</code> 部分可以有多个。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\necho -n &quot;输入一个 1 到 3 之间的数字(包含两端)&gt; &quot;\nread character\nif [ &quot;$character&quot; = &quot;1&quot; ]; then\n    echo 1\nelif [ &quot;$character&quot; = &quot;2&quot; ]; then\n    echo 2\nelif [ &quot;$character&quot; = &quot;3&quot; ]; then\n    echo 3\nelse\n    echo 输入不符合要求\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p><h2 id="test-命令" tabindex="-1"><a class="header-anchor" href="#test-命令" aria-hidden="true">#</a> test 命令</h2><p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code># 写法一\ntest expression\n\n# 写法二\n[ expression ]\n\n# 写法三\n[[ expression ]]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p><p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ test -f /etc/hosts\n$ echo $?\n0\n\n$ [ -f /etc/hosts ]\n$  echo $?\n0\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p><p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p><p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code># 写法一\nif test -e /tmp/foo.txt ; then\n  echo &quot;Found foo.txt&quot;\nfi\n\n# 写法二\nif [ -e /tmp/foo.txt ] ; then\n  echo &quot;Found foo.txt&quot;\nfi\n\n# 写法三\nif [[ -e /tmp/foo.txt ]] ; then\n  echo &quot;Found foo.txt&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="判断表达式" tabindex="-1"><a class="header-anchor" href="#判断表达式" aria-hidden="true">#</a> 判断表达式</h2><p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p><p>常用的判断表达式有下面这些。</p><h3 id="文件判断" tabindex="-1"><a class="header-anchor" href="#文件判断" aria-hidden="true">#</a> 文件判断</h3><p>以下表达式用来判断文件状态。</p><ul><li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li><li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li><li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li><li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li><li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li><li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li><li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li><li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li><li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li><li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li><li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li><li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li><li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li><li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li><li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li><li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li><li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li><li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li><li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li><li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li><li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li><li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li><li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li><li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li></ul><p>下面是一个示例。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nFILE=~/.bashrc\n\nif [ -e &quot;$FILE&quot; ]; then\n  if [ -f &quot;$FILE&quot; ]; then\n    echo &quot;$FILE is a regular file.&quot;\n  fi\n  if [ -d &quot;$FILE&quot; ]; then\n    echo &quot;$FILE is a directory.&quot;\n  fi\n  if [ -r &quot;$FILE&quot; ]; then\n    echo &quot;$FILE is readable.&quot;\n  fi\n  if [ -w &quot;$FILE&quot; ]; then\n    echo &quot;$FILE is writable.&quot;\n  fi\n  if [ -x &quot;$FILE&quot; ]; then\n    echo &quot;$FILE is executable/searchable.&quot;\n  fi\nelse\n  echo &quot;$FILE does not exist&quot;\n  exit 1\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p><h3 id="字符串判断" tabindex="-1"><a class="header-anchor" href="#字符串判断" aria-hidden="true">#</a> 字符串判断</h3><p>以下表达式用来判断字符串。</p><ul><li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li><li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li><li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li><li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li><li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li><li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li><li><code>[ string1 &#39;&gt;&#39; string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li><li><code>[ string1 &#39;&lt;&#39; string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li></ul><p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p><p>下面是一个示例。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nANSWER=maybe\n\nif [ -z &quot;$ANSWER&quot; ]; then\n  echo &quot;There is no answer.&quot; &gt;&amp;2\n  exit 1\nfi\nif [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then\n  echo &quot;The answer is YES.&quot;\nelif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then\n  echo &quot;The answer is NO.&quot;\nelif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then\n  echo &quot;The answer is MAYBE.&quot;\nelse\n  echo &quot;The answer is UNKNOWN.&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p><p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p><h3 id="整数判断" tabindex="-1"><a class="header-anchor" href="#整数判断" aria-hidden="true">#</a> 整数判断</h3><p>下面的表达式用于判断整数。</p><ul><li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li><li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li></ul><p>下面是一个用法的例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nINT=-5\n\nif [ -z &quot;$INT&quot; ]; then\n  echo &quot;INT is empty.&quot; &gt;&amp;2\n  exit 1\nfi\nif [ $INT -eq 0 ]; then\n  echo &quot;INT is zero.&quot;\nelse\n  if [ $INT -lt 0 ]; then\n    echo &quot;INT is negative.&quot;\n  else\n    echo &quot;INT is positive.&quot;\n  fi\n  if [ $((INT % 2)) -eq 0 ]; then\n    echo &quot;INT is even.&quot;\n  else\n    echo &quot;INT is odd.&quot;\n  fi\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p><h3 id="正则判断" tabindex="-1"><a class="header-anchor" href="#正则判断" aria-hidden="true">#</a> 正则判断</h3><p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>[[ string1 =~ regex ]]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p><p>下面是一个例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nINT=-5\n\nif [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then\n  echo &quot;INT is an integer.&quot;\n  exit 0\nelse\n  echo &quot;INT is not an integer.&quot; &gt;&amp;2\n  exit 1\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p><h3 id="test-判断的逻辑运算" tabindex="-1"><a class="header-anchor" href="#test-判断的逻辑运算" aria-hidden="true">#</a> test 判断的逻辑运算</h3><p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p><ul><li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li><li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li><li><code>NOT</code> 运算: 符号 <code>!</code>。</li></ul><p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nMIN_VAL=1\nMAX_VAL=100\n\nINT=50\n\nif [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then\n  if [[ $INT -ge $MIN_VAL &amp;&amp; $INT -le $MAX_VAL ]]; then\n    echo &quot;$INT is within $MIN_VAL to $MAX_VAL.&quot;\n  else\n    echo &quot;$INT is out of range.&quot;\n  fi\nelse\n  echo &quot;INT is not an integer.&quot; &gt;&amp;2\n  exit 1\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p><p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if [ ! \\( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \\) ]; then\n    echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot;\nelse\n    echo &quot;$INT is in range.&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p><h3 id="算术判断" tabindex="-1"><a class="header-anchor" href="#算术判断" aria-hidden="true">#</a> 算术判断</h3><p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if ((3 &gt; 2)); then\n  echo &quot;true&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p><p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p><p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if ((1)); then echo &quot;It is true.&quot;; fi\nIt is true.\n$ if ((0)); then echo &quot;It is true.&quot;; else echo &quot;it is false.&quot;; fi\nIt is false.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p><p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if (( foo = 5 ));then echo &quot;foo is $foo&quot;; fi\nfoo is 5\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p><p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ if (( foo = 0 ));then echo &quot;It is true.&quot;;else echo &quot;It is false.&quot;; fi\nIt is false.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>下面是用算术条件改写的数值判断脚本。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nINT=-5\n\nif [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then\n  if ((INT == 0)); then\n    echo &quot;INT is zero.&quot;\n  else\n    if ((INT &lt; 0)); then\n      echo &quot;INT is negative.&quot;\n    else\n      echo &quot;INT is positive.&quot;\n    fi\n    if (( ((INT % 2)) == 0)); then\n      echo &quot;INT is even.&quot;\n    else\n      echo &quot;INT is odd.&quot;\n    fi\n  fi\nelse\n  echo &quot;INT is not an integer.&quot; &gt;&amp;2\n  exit 1\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div>',85),i=(0,a.Uk)("只要是算术表达式，都能用于 "),r=(0,a._)("code",null,"((...))",-1),o=(0,a.Uk)(" 语法，详见 "),d=(0,a.Uk)("Bash 的算术运算"),p=(0,a.Uk)(" 一章。"),u=(0,a.uE)('<h3 id="普通命令的逻辑运算" tabindex="-1"><a class="header-anchor" href="#普通命令的逻辑运算" aria-hidden="true">#</a> 普通命令的逻辑运算</h3><p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>command1 &amp;&amp; command2\ncommand1 || command2\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>mkdir temp &amp;&amp; cd temp\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>[ -d temp ] || mkdir temp\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>[ ! -d temp ] &amp;&amp; exit 1\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p><p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>if [ condition ] &amp;&amp; [ condition ]; then\n  command\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>下面是一个示例。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#! /bin/bash\n\nfilename=$1\nword1=$2\nword2=$3\n\nif grep $word1 $filename &amp;&amp; grep $word2 $filename\nthen\n  echo &quot;$word1 and $word2 are both in $filename.&quot;\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p><p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>[[ -d &quot;$dir_name&quot; ]] &amp;&amp; cd &quot;$dir_name&quot; &amp;&amp; rm *\n\n# 等同于\n\nif [[ ! -d &quot;$dir_name&quot; ]]; then\n  echo &quot;No such directory: &#39;$dir_name&#39;&quot; &gt;&amp;2\n  exit 1\nfi\nif ! cd &quot;$dir_name&quot;; then\n  echo &quot;Cannot cd to &#39;$dir_name&#39;&quot; &gt;&amp;2\n  exit 1\nfi\nif ! rm *; then\n  echo &quot;File deletion failed. Check results&quot; &gt;&amp;2\n  exit 1\nfi\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="case-结构" tabindex="-1"><a class="header-anchor" href="#case-结构" aria-hidden="true">#</a> case 结构</h2><p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>case expression in\n  pattern )\n    commands ;;\n  pattern )\n    commands ;;\n  ...\nesac\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\necho -n &quot;输入一个 1 到 3 之间的数字(包含两端)&gt; &quot;\nread character\ncase $character in\n  1 ) echo 1\n    ;;\n  2 ) echo 2\n    ;;\n  3 ) echo 3\n    ;;\n  * ) echo 输入不符合要求\nesac\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p><p>下面是另一个例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\nOS=$(uname -s)\n\ncase &quot;$OS&quot; in\n  FreeBSD) echo &quot;This is FreeBSD&quot; ;;\n  Darwin) echo &quot;This is Mac OSX&quot; ;;\n  AIX) echo &quot;This is AIX&quot; ;;\n  Minix) echo &quot;This is Minix&quot; ;;\n  Linux) echo &quot;This is Linux&quot; ;;\n  *) echo &quot;Failed to identify this OS&quot; ;;\nesac\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的例子判断当前是什么操作系统。</p><p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p><ul><li><code>a)</code>: 匹配 <code>a</code>。</li><li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li><li><code>[[:alpha:]])</code>: 匹配单个字母。</li><li><code>???)</code>: 匹配 3 个字符的单词。</li><li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li><li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n\necho -n &quot;输入一个字母或数字 &gt; &quot;\nread character\ncase $character in\n  [[:lower:]] | [[:upper:]] ) echo &quot;输入了字母 $character&quot;\n                              ;;\n  [0-9] )                     echo &quot;输入了数字 $character&quot;\n                              ;;\n  * )                         echo &quot;输入不符合要求&quot;\nesac\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p><p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n# test.sh\n\nread -n 1 -p &quot;Type a character &gt; &quot;\necho\ncase $REPLY in\n  [[:upper:]])    echo &quot;&#39;$REPLY&#39; is upper case.&quot; ;;&amp;\n  [[:lower:]])    echo &quot;&#39;$REPLY&#39; is lower case.&quot; ;;&amp;\n  [[:alpha:]])    echo &quot;&#39;$REPLY&#39; is alphabetic.&quot; ;;&amp;\n  [[:digit:]])    echo &quot;&#39;$REPLY&#39; is a digit.&quot; ;;&amp;\n  [[:graph:]])    echo &quot;&#39;$REPLY&#39; is a visible character.&quot; ;;&amp;\n  [[:punct:]])    echo &quot;&#39;$REPLY&#39; is a punctuation symbol.&quot; ;;&amp;\n  [[:space:]])    echo &quot;&#39;$REPLY&#39; is a whitespace character.&quot; ;;&amp;\n  [[:xdigit:]])   echo &quot;&#39;$REPLY&#39; is a hexadecimal digit.&quot; ;;&amp;\nesac\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行上面的脚本，会得到下面的结果。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ test.sh\nType a character &gt; a\n&#39;a&#39; is lower case.\n&#39;a&#39; is alphabetic.\n&#39;a&#39; is a visible character.\n&#39;a&#39; is a hexadecimal digit.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>',36),b={href:"http://linuxcommand.org/tlcl.php",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Uk)("The Linux command-line"),m=(0,a.Uk)(", William Shotts"),h={href:"https://www.pcwdld.com/linux-commands-cheat-sheet",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("Linux Commands Cheat Sheet"),f=(0,a.Uk)(" (一个很简短的 CheatSheet)"),q={},v=(0,s(82831).Z)(q,[["render",function(e,n){const s=(0,a.up)("RouterLink"),q=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[c,(0,a.kq)(" more "),l,(0,a._)("p",null,[i,r,o,(0,a.Wm)(s,{to:"/linux/bash/arithmetic.html"},{default:(0,a.w5)((()=>[d])),_:1}),p]),u,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",b,[t,(0,a.Wm)(q)]),m]),(0,a._)("li",null,[(0,a._)("a",h,[g,(0,a.Wm)(q)]),f])])],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}},1609:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-a381d276",path:"/linux/bash/condition.html",title:"条件判断",lang:"zh-CN",frontmatter:{title:"条件判断",icon:"condition",author:"阮一峰",category:["Linux"],tag:["Bash"],copyright:'本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" rel="noopener noreferrer" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>',summary:"本章介绍 Bash 脚本的条件判断语法。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/linux/bash/condition.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"条件判断"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-12T05:50:30.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"阮一峰"}],["meta",{property:"article:tag",content:"Bash"}],["meta",{property:"article:modified_time",content:"2022-02-12T05:50:30.000Z"}]]},excerpt:"<p>本章介绍 Bash 脚本的条件判断语法。</p>\n",headers:[{level:2,title:"if 结构",slug:"if-结构",children:[]},{level:2,title:"test 命令",slug:"test-命令",children:[]},{level:2,title:"判断表达式",slug:"判断表达式",children:[{level:3,title:"文件判断",slug:"文件判断",children:[]},{level:3,title:"字符串判断",slug:"字符串判断",children:[]},{level:3,title:"整数判断",slug:"整数判断",children:[]},{level:3,title:"正则判断",slug:"正则判断",children:[]},{level:3,title:"test 判断的逻辑运算",slug:"test-判断的逻辑运算",children:[]},{level:3,title:"算术判断",slug:"算术判断",children:[]},{level:3,title:"普通命令的逻辑运算",slug:"普通命令的逻辑运算",children:[]}]},{level:2,title:"case 结构",slug:"case-结构",children:[]},{level:2,title:"参考链接",slug:"参考链接",children:[]}],git:{createdTime:1591204114e3,updatedTime:164464503e4,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:9}]},readingTime:{minutes:13.82,words:4146},filePathRelative:"linux/bash/condition.md"}}}]);