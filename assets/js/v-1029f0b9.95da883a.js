"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[53308],{71198:(n,e,a)=>{a.r(e),a.d(e,{default:()=>i});const s=(0,a(34086).uE)('<h2 id="name-属性" tabindex="-1"><a class="header-anchor" href="#name-属性" aria-hidden="true">#</a> name 属性</h2><p>函数的 <code>name</code> 属性返回函数的名字。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function f1() {}\nf1.name; // &quot;f1&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果是通过变量赋值定义的函数，那么 <code>name</code> 属性返回变量名。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var f2 = function () {};\nf2.name; // &quot;f2&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么 <code>name</code> 属性返回 <code>function</code> 关键字之后的那个函数名。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var f3 = function myName() {};\nf3.name; // &#39;myName&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面代码中，<code>f3.name</code> 返回函数表达式的名字。注意，真正的函数名还是 <code>f3</code>，而 <code>myName</code> 这个名字只在函数体内部可用。</p><p><code>name</code> 属性的一个用处，就是获取参数函数的名字。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var myFunc = function () {};\n\nfunction test(f) {\n  console.log(f.name);\n}\n\ntest(myFunc); // myFunc\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面代码中，函数 <code>test</code> 内部通过 <code>name</code> 属性，就可以知道传入的参数是什么函数。</p><h2 id="length-属性" tabindex="-1"><a class="header-anchor" href="#length-属性" aria-hidden="true">#</a> length 属性</h2><p>函数的 <code>length</code> 属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function f(a, b) {}\nf.length; // 2\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面代码定义了空函数 <code>f</code>，它的 <code>length</code> 属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code> 属性始终等于 2。</p><p><code>length</code> 属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”(overload)。</p><h2 id="tostring" tabindex="-1"><a class="header-anchor" href="#tostring" aria-hidden="true">#</a> toString()</h2><p>函数的 <code>toString</code> 方法返回一个字符串，内容是函数的源码。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function f() {\n  a();\n  b();\n  c();\n}\n\nf.toString();\n// function f() {\n//  a();\n//  b();\n//  c();\n// }\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>对于那些原生的函数，<code>toString()</code> 方法返回 <code>function (){[native code]}</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Math.sqrt.toString();\n// &quot;function sqrt() { [native code] }&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面代码中，<code>Math.sqrt</code> 是 JavaScript 引擎提供的原生函数，<code>toString()</code> 方法就返回原生代码的提示。</p><p>函数内部的注释也可以返回。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function f() {/*\n  这是一个\n  多行注释\n*/}\n\nf.toString();\n// &quot;function f(){/*\n//   这是一个\n//   多行注释\n// */}&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>利用这一点，可以变相实现多行字符串。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var multiline = function (fn) {\n  var arr = fn.toString().split(&quot;\\n&quot;);\n  return arr.slice(1, arr.length - 1).join(&quot;\\n&quot;);\n};\n\nfunction f() {/*\n  这是一个\n  多行注释\n*/}\n\nmultiline(f);\n// &quot; 这是一个\n//   多行注释&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>',26),r={},i=(0,a(82831).Z)(r,[["render",function(n,e){return s}]])},82831:(n,e)=>{e.Z=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},12885:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-1029f0b9",path:"/code/language/js/function/method.html",title:"函数的属性和方法",lang:"zh-CN",frontmatter:{title:"函数的属性和方法",icon:"list",category:["JavaScript"],summary:"name 属性 函数的 name 属性返回函数的名字。 如果是通过变量赋值定义的函数，那么 name 属性返回变量名。 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么 name 属性返回 function 关键字之后的那个函数名。 上面代码中，f3.name 返回函数表达式的名字。注意，真正的函数名还是 f3，而",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/function/method.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"函数的属性和方法"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2021-01-28T12:33:56.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:modified_time",content:"2021-01-28T12:33:56.000Z"}]]},excerpt:"",headers:[{level:2,title:"name 属性",slug:"name-属性",children:[]},{level:2,title:"length 属性",slug:"length-属性",children:[]},{level:2,title:"toString()",slug:"tostring",children:[]}],git:{createdTime:1591204114e3,updatedTime:1611837236e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:3}]},readingTime:{minutes:1.74,words:522},filePathRelative:"code/language/js/function/method.md"}}}]);