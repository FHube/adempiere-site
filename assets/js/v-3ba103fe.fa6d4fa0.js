"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[15804],{27377:(s,n,a)=>{a.r(n),a.d(n,{default:()=>p});const e=(0,a(66252).uE)('<h2 id="cp-命令" tabindex="-1"><a class="header-anchor" href="#cp-命令" aria-hidden="true">#</a> cp 命令</h2><p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p><p>cp 命令的基本格式如下:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp [选项] 源文件 目标文件</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>选项:</p><ul><li>-a: 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li><li>-d: 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接；</li><li>-i: 询问，如果目标文件已经存在，则会询问是否覆盖；</li><li>-l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li><li>-s: 把目标文件建立为源文件的软链接文件，而不是复制源文件；</li><li>-p: 复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)；</li><li>-r: 递归复制，用于复制目录；</li><li>-u: 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li></ul><p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p><h3 id="cp-命令基本用法" tabindex="-1"><a class="header-anchor" href="#cp-命令基本用法" aria-hidden="true">#</a> cp 命令基本用法</h3><p>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch cangls</span>\n<span class="token comment">#建立源文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp cangls /tmp/</span>\n<span class="token comment">#把源文件不改名复制到 /tmp/ 目录下</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果需要改名复制，则命令如下:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp cangls /tmp/bols</span>\n<span class="token comment">#改名复制</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是 <code>cp -i</code> 的别名，例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp cangls /tmp/</span>\ncp:是否覆盖<span class="token string">&quot;/tmp/cangls&quot;</span>?y\n<span class="token comment">#目标位置有同名文件，所以会提示是否覆盖</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 <code>-r</code> 选项即可，例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir movie</span>\n<span class="token comment">#建立测试目录</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp -r /root/movie/ /tmp/</span>\n<span class="token comment">#目录原名复制</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="复制软链接文件" tabindex="-1"><a class="header-anchor" href="#复制软链接文件" aria-hidden="true">#</a> 复制软链接文件</h3><p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢? 我们试试:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ln -s /root/cangls /tmp/cangls_slink</span>\n<span class="token comment">#建立一个测试软链接文件/tmp/cangls_slink</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll /tmp/cangls_slink</span>\nlrwxrwxrwx <span class="token number">1</span> root root <span class="token number">12</span> <span class="token number">6</span> 月 <span class="token number">14</span> 05:53 /tmp/cangls_slink -<span class="token operator">&gt;</span> /root/cangls\n<span class="token comment">#源文件本身就是一个软链接文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp /tmp/cangls_slink /tmp/cangls_t1</span>\n<span class="token comment">#复制软链接文件，但是不加&quot;-d&quot;选项</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp -d /tmp/cangls_slink /tmp/cangls_t2</span>\n<span class="token comment">#复制软链接文件，加入&quot;-d&quot;选项</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll /tmp/cangls_t1 /tmp/cangls_t2</span>\n-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> <span class="token number">6</span>月 <span class="token number">14</span> 05:56 /tmp/cangls_t1\n<span class="token comment">#会发现不加&quot;-d&quot;选项，实际复制的是软链接的源文件，而不是软链接文件</span>\nlrwxrwxrwx <span class="token number">1</span> root root <span class="token number">12</span> <span class="token number">6</span> 月 <span class="token number">14</span> 05:56/tmp/ cangls_t2-<span class="token operator">&gt;</span> /root/cangls\n<span class="token comment">#而如果加入了&quot;-d&quot;选项，则会复制软链接文件</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这个例子说明，如果在复制软链接文件时不使用 <code>-d</code> 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 <code>-d</code> 选项，才会复制软链接文件。请大家注意，<code>-d</code> 选项对硬链接是无效的。</p><h3 id="保留源文件属性复制" tabindex="-1"><a class="header-anchor" href="#保留源文件属性复制" aria-hidden="true">#</a> 保留源文件属性复制</h3><p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp /var/lib/mlocate/mlocate.db /tmp/</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll /var/lib/mlocate/mlocate.db</span>\n-rw-r-----1 root slocate2328027 <span class="token number">6</span>月 <span class="token number">14</span> 02:08/var/lib/mlocate/mlocate.db\n<span class="token comment">#注意源文件的时间和所属组</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#ll /tmp/mlocate.db</span>\n-rw-r----- <span class="token number">1</span> root root2328027 <span class="token number">6</span> 月 <span class="token number">14</span> 06:05/tmp/mlocate.db\n<span class="token comment">#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 <code>-p</code> 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span>\n<span class="token comment">#使用&quot;-p&quot;选项</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span>\n-rw-r----- root <span class="token function">slocate</span> <span class="token number">2328027</span> <span class="token number">6</span>月 <span class="token number">14</span> 02:08 /tmp/mlocate.db_2\n-rw-r----- root <span class="token function">slocate</span> <span class="token number">2328027</span> <span class="token number">6</span>月 <span class="token number">14</span> 02:08 /var/lib/mlocate/mlocate.db\n<span class="token comment">#源文件和目标文件的所有属性都一致，包括时间</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们之前讲过，<code>-a</code> 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 <code>-a</code> 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 <code>-a</code> 选项来取代 &quot;-d、-p、-r&quot; 选项更加方便。</p><h3 id="l-和-s-选项" tabindex="-1"><a class="header-anchor" href="#l-和-s-选项" aria-hidden="true">#</a> &quot;-l&quot; 和 &quot;-s&quot; 选项</h3><p>我们如果使用 <code>-l</code> 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 <code>-s</code> 选项，则目标文件会被建立为源文件的软链接。</p><p>这两个选项和 <code>-d</code> 选项是不同的，<code>d</code> 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 <code>-l</code> 和 <code>-s</code> 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch bols</span>\n<span class="token comment">#建立测试文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll -i bols</span>\n<span class="token number">262154</span>-rw-r--r-- <span class="token number">1</span> root root <span class="token number">0</span> <span class="token number">6</span>月 <span class="token number">14</span> 06:26 bols\n<span class="token comment">#源文件只是一个普通文件，而不是软链接文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp -l /root/bols /tmp/bols_h</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cp -s /root/bols /tmp/bols_s</span>\n<span class="token comment">#使用&quot;-l&quot; 和&quot;-s&quot;选项复制</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ll -i /tmp/bols_h /tmp/bols_s</span>\n<span class="token number">262154</span>-rw-r--r-- 2root root <span class="token number">0</span> <span class="token number">6</span> 月 <span class="token number">14</span> 06:26/tmp/bols_h\n<span class="token comment">#目标文件 /tmp/bols_h 为源文件的硬链接文件</span>\n<span class="token number">932113</span> lrwxrwxrwx <span class="token number">1</span> root root <span class="token number">10</span> <span class="token number">6</span> 月 <span class="token number">14</span> 06:27/tmp/bols_s -<span class="token operator">&gt;</span> /root/bols\n<span class="token comment">#目标文件 /tmp/bols_s 为源文件的软链接文件</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="rm-命令" tabindex="-1"><a class="header-anchor" href="#rm-命令" aria-hidden="true">#</a> rm 命令</h2><p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件(即垃圾)，这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p><p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rm[选项] 文件或目录</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>选项:</p><ul><li>-f: 强制删除(force)，和 <code>-i</code> 选项相反，使用 <code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li><li>-i: 和 <code>-f</code> 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 <code>-i</code> 可以有效防止不小心删除有用的文件或目录。</li><li>-r: 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li></ul><div class="custom-container tip"><p class="custom-container-title">提示</p><p>rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p></div><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法" aria-hidden="true">#</a> 基本用法</h3><p>rm 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch cangls</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rm cangls</span>\nrm:是否删除普通空文件<span class="token string">&quot;cangls&quot;</span>?y\n<span class="token comment">#删除前会询问是否删除</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="删除目录" tabindex="-1"><a class="header-anchor" href="#删除目录" aria-hidden="true">#</a> 删除目录</h3><p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /test/lm/movie/jp</span>\n<span class="token comment">#递归建立测试目录</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rm /test</span>\nrm:无法删除<span class="token string">&quot;/test/&quot;</span><span class="token builtin class-name">:</span> 是一个目录\n<span class="token comment">#如果不加&quot;-r&quot;选项，则会报错</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rm -r /test</span>\nrm:是否进入目录<span class="token string">&quot;/test&quot;</span>?y\nrm:是否进入目录<span class="token string">&quot;/test/lm/movie&quot;</span>?y\nrm:是否删除目录<span class="token string">&quot;/test/lm/movie/jp&quot;</span>?y\nrm:是否删除目录<span class="token string">&quot;/test/lm/movie&quot;</span>?y\nrm:是否删除目录<span class="token string">&quot;/test/lm&quot;</span>?y\nrm:是否删除目录<span class="token string">&quot;/test&quot;</span>?y\n<span class="token comment">#会分别询问是否进入子目录、是否删除子目录</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p><h3 id="强制删除" tabindex="-1"><a class="header-anchor" href="#强制删除" aria-hidden="true">#</a> 强制删除</h3><p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir -p /test/lm/movie/jp</span>\n<span class="token comment">#重新建立测试目录</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># rm -rf /test</span>\n<span class="token comment">#强制删除，一了百了</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p><p>虽然 <code>-rf</code> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <code>-rf</code> 选项。</p><h2 id="mv-命令" tabindex="-1"><a class="header-anchor" href="#mv-命令" aria-hidden="true">#</a> mv 命令</h2><p>mv 命令(move 的缩写)，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv 【选项】 源文件 目标文件</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>选项:</p><ul><li>-f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li><li>-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)；</li><li>-n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li><li>-v: 显示文件或目录的移动过程；</li><li>-u: 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li></ul><p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p><h3 id="移动文件或目录" tabindex="-1"><a class="header-anchor" href="#移动文件或目录" aria-hidden="true">#</a> 移动文件或目录</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv cangls /tmp</span>\n<span class="token comment">#移动之后，源文件会被删除，类似剪切</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mkdir movie</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv movie/ /tmp</span>\n<span class="token comment">#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 &quot;-r&quot; 选项</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 <code>mv -i</code> 的别名，例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch cangls</span>\n<span class="token comment">#重新建立文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv cangls /tmp</span>\nmv:县否覆盖<span class="token string">&quot;tmp/cangls&quot;</span>? y\n<span class="token comment">#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="强制移动" tabindex="-1"><a class="header-anchor" href="#强制移动" aria-hidden="true">#</a> 强制移动</h3><p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p><p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 <code>-f</code> 选项进行强制移动，这就不再需要用户手工确认了。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch cangls</span>\n<span class="token comment">#重新建立文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv -f cangls /tmp</span>\n<span class="token comment">#就算 /tmp/ 目录下已经存在同名的文件，由于&quot;-f&quot;选项的作用，所以会强制覆盖</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="不覆盖移动" tabindex="-1"><a class="header-anchor" href="#不覆盖移动" aria-hidden="true">#</a> 不覆盖移动</h3><p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 <code>-n</code> 选项的帮助了。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># ls /tmp</span>\n/tmp/bols /tmp/cangls\n<span class="token comment">#在/tmp/目录下已经存在bols、cangls文件了</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv -vn bols cangls lmls /tmp/、</span>\n<span class="token string">&quot;lmls&quot;</span>-<span class="token operator">&gt;</span><span class="token string">&quot;/tmp/lmls&quot;</span>\n<span class="token comment">#再向 /tmp/ 目录中移动同名文件，如果使用了 &quot;-n&quot; 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动(&quot;-v&quot; 选项用于显示移动过程)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="改名" tabindex="-1"><a class="header-anchor" href="#改名" aria-hidden="true">#</a> 改名</h3><p>如果源文件和目标文件在同一目录中，那就是改名。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv bols lmls</span>\n<span class="token comment">#把 bols 改名为 lmls</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>目录也可以按照同样的方法改名。</p><h3 id="显示移动过程" tabindex="-1"><a class="header-anchor" href="#显示移动过程" aria-hidden="true">#</a> 显示移动过程</h3><p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 <code>-v</code> 选项来查看详细的移动信息。例如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># touch test1.txt test2.txt test3.txt</span>\n<span class="token comment">#建立三个测试文件</span>\n<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># mv -v *.txt /tmp</span>\n<span class="token string">&quot;test1.txt&quot;</span> -<span class="token operator">&gt;</span> <span class="token string">&quot;/tmp/test1.txt&quot;</span>\n<span class="token string">&quot;test2.txt&quot;</span> -<span class="token operator">&gt;</span> <span class="token string">&quot;/tmp/test2.txt&quot;</span>\n<span class="token string">&quot;test3.txt&quot;</span> -<span class="token operator">&gt;</span> <span class="token string">&quot;/tmp/test3.txt&quot;</span>\n<span class="token comment">#加入&quot;-v&quot;选项，可以看到有哪些文件进行了移</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div>',73),t={},p=(0,a(83744).Z)(t,[["render",function(s,n){return e}]])},83744:(s,n)=>{n.Z=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},52713:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-3ba103fe",path:"/linux/command/other.html",title:"其他文件命令",lang:"zh-CN",frontmatter:{title:"其他文件命令",icon:"sort",date:"2019-11-19T00:00:00.000Z",category:["Linux"],head:[["meta",{property:"og:url",content:"https://mrhope.site/linux/command/other.html"}],["meta",{property:"og:title",content:"其他文件命令"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{name:"twitter:card",content:"summary_large_image"}],["meta",{property:"article:published_time",content:"2019-11-19T00:00:00.000Z"}],["script",{type:"application/ld+json"},'{"@context":"https://schema.org","@type":"NewsArticle","headline":"其他文件命令","image":[""],"datePublished":"2019-11-19T00:00:00.000Z","dateModified":"","author":[]}']]},excerpt:"",headers:[{level:2,title:"cp 命令",slug:"cp-命令",children:[{level:3,title:"cp 命令基本用法",slug:"cp-命令基本用法",children:[]},{level:3,title:"复制软链接文件",slug:"复制软链接文件",children:[]},{level:3,title:"保留源文件属性复制",slug:"保留源文件属性复制",children:[]},{level:3,title:'"-l" 和 "-s" 选项',slug:"l-和-s-选项",children:[]}]},{level:2,title:"rm 命令",slug:"rm-命令",children:[{level:3,title:"基本用法",slug:"基本用法",children:[]},{level:3,title:"删除目录",slug:"删除目录",children:[]},{level:3,title:"强制删除",slug:"强制删除",children:[]}]},{level:2,title:"mv 命令",slug:"mv-命令",children:[{level:3,title:"移动文件或目录",slug:"移动文件或目录",children:[]},{level:3,title:"强制移动",slug:"强制移动",children:[]},{level:3,title:"不覆盖移动",slug:"不覆盖移动",children:[]},{level:3,title:"改名",slug:"改名",children:[]},{level:3,title:"显示移动过程",slug:"显示移动过程",children:[]}]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:4}]},readingTime:{minutes:10.88,words:3264},filePathRelative:"linux/command/other.md"}}}]);