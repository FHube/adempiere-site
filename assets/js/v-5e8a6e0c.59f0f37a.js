"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[89776],{47856:(e,n,s)=>{s.r(n),s.d(n,{default:()=>p});var a=s(34086);const l=(0,a._)("p",null,"本章介绍 Bash 函数的用法。",-1),r=(0,a.uE)('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p><p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p><p>Bash 函数定义的语法有两种。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code># 第一种\nfn() {\n  # codes\n}\n\n# 第二种\nfunction fn() {\n  # codes\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p><p>下面是一个简单函数的例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>hello() {\n  echo &quot;Hello $1&quot;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p><p>调用时，就直接写函数名，参数跟在函数名后面。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ hello world\nhello world\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>today() {\n  echo -n &quot;Today&#39;s date is: &quot;\n  date +&quot;%A, %B %-d, %Y&quot;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>unset -f functionName\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>declare -f\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p><p><code>declare</code> 命令还支持查看单个函数的定义。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>declare -f functionName\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>declare -F\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="参数变量" tabindex="-1"><a class="header-anchor" href="#参数变量" aria-hidden="true">#</a> 参数变量</h2><p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p><ul><li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li><li><code>$0</code>: 函数所在的脚本名。</li><li><code>$#</code>: 函数的参数总数。</li><li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li><li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li></ul><p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p><p>下面是一个示例脚本 <code>test.sh</code>。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>#!/bin/bash\n# test.sh\n\nfunction alice {\n  echo &quot;alice: $@&quot;\n  echo &quot;$0: $1 $2 $3 $4&quot;\n  echo &quot;$# arguments&quot;\n\n}\n\nalice in wonderland\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>运行该脚本，结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ bash test.sh\nalice: in wonderland\ntest.sh: in wonderland\n2 arguments\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p><p>下面是一个日志函数的例子。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>function log_msg {\n  echo &quot;[`date &#39;+ %F %T&#39;` ]: $@&quot;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>使用方法如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ log_msg &quot;This is sample log message&quot;\n[ 2018-08-16 19:56:34 ]: This is sample log message\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="return-命令" tabindex="-1"><a class="header-anchor" href="#return-命令" aria-hidden="true">#</a> return 命令</h2><p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>function func_return_value {\n  return 10\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ func_return_value\n$ echo &quot;Value returned by function is: $?&quot;\nValue returned by function is: 10\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>function name {\n  commands\n  return\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="全局变量和局部变量-local-命令" tabindex="-1"><a class="header-anchor" href="#全局变量和局部变量-local-命令" aria-hidden="true">#</a> 全局变量和局部变量，local 命令</h2><p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code># 脚本 test.sh\nfn () {\n  foo=1\n  echo &quot;fn: foo = $foo&quot;\n}\n\nfn\necho &quot;global: foo = $foo&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面脚本的运行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ bash test.sh\nfn: foo = 1\nglobal: foo = 1\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p><p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>foo=1\n\nfn () {\n  foo=2\n}\n\necho $foo\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p><p>函数里面可以用 <code>local</code> 命令声明局部变量。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code># 脚本 test.sh\nfn () {\n  local foo\n  foo=1\n  echo &quot;fn: foo = $foo&quot;\n}\n\nfn\necho &quot;global: foo = $foo&quot;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上面脚本的运行结果如下。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ bash test.sh\nfn: foo = 1\nglobal: foo =\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>',57),i={href:"https://www.linuxtechi.com/define-use-functions-linux-shell-script/",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("How to define and use functions in Linux Shell Script"),d=(0,a.Uk)(", by Pradeep Kumar"),o={},p=(0,s(82831).Z)(o,[["render",function(e,n){const s=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,(0,a.kq)(" more "),r,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",i,[c,(0,a.Wm)(s)]),d])])],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}},41930:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-5e8a6e0c",path:"/linux/bash/function.html",title:"Bash 函数",lang:"zh-CN",frontmatter:{title:"Bash 函数",icon:"function",author:"阮一峰",category:["Linux"],tag:["Bash"],copyright:'本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" rel="noopener noreferrer" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>',summary:"本章介绍 Bash 函数的用法。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/linux/bash/function.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"Bash 函数"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-12T05:50:30.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"阮一峰"}],["meta",{property:"article:tag",content:"Bash"}],["meta",{property:"article:modified_time",content:"2022-02-12T05:50:30.000Z"}]]},excerpt:"<p>本章介绍 Bash 函数的用法。</p>\n",headers:[{level:2,title:"简介",slug:"简介",children:[]},{level:2,title:"参数变量",slug:"参数变量",children:[]},{level:2,title:"return 命令",slug:"return-命令",children:[]},{level:2,title:"全局变量和局部变量，local 命令",slug:"全局变量和局部变量-local-命令",children:[]},{level:2,title:"参考链接",slug:"参考链接",children:[]}],git:{createdTime:1591204114e3,updatedTime:164464503e4,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:5}]},readingTime:{minutes:3.73,words:1120},filePathRelative:"linux/bash/function.md"}}}]);