"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5079],{86515:(e,n,a)=>{a.r(n),a.d(n,{default:()=>t});const s=(0,a(34086).uE)('<p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>abs(10); // 返回 10\nabs(-9); // 返回 9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于 JavaScript 允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>abs(10, &quot;blablabla&quot;); // 返回 10\nabs(-9, &quot;haha&quot;, &quot;hehe&quot;, null); // 返回 9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>传入的参数比定义的少也没有问题:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>abs(); // 返回 NaN\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此时 <code>abs(x)</code> 函数的参数 x 将收到 <code>undefined</code>，计算结果为 <code>NaN</code>。</p><p>要避免收到 <code>undefined</code>，可以对参数进行检查:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function abs(x) {\n  if (typeof x !== &quot;number&quot;) throw &quot;Not a number&quot;;\n\n  if (x &gt;= 0) return x;\n  else return -x;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="递归调用" tabindex="-1"><a class="header-anchor" href="#递归调用" aria-hidden="true">#</a> 递归调用</h2><p>函数可以调用自身，这就是递归(recursion)。下面就是通过递归，计算斐波那契数列的代码。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function fib(num) {\n  if (num === 0) return 0;\n  if (num === 1) return 1;\n  return fib(num - 2) + fib(num - 1);\n}\n\nfib(6); // 8\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>上面代码中，<code>fib</code> 函数内部又调用了 <code>fib</code>，计算得到斐波那契数列的第 6 个元素是 8。</p>',13),r={},t=(0,a(82831).Z)(r,[["render",function(e,n){return s}]])},82831:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},41785:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-797b419c",path:"/code/language/js/function/call.html",title:"函数的调用",lang:"zh-CN",frontmatter:{title:"函数的调用",icon:"call",date:"2019-10-02T00:00:00.000Z",category:["JavaScript"],summary:"调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 由于 JavaScript 允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数: 传入的参数比定义的少也没有问题: 此时 abs(x) 函数的参数 x 将收到 undefined，计算结果为 NaN。 要避免收到 undefined，可以对参数",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/function/call.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"函数的调用"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:published_time",content:"2019-10-02T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"",headers:[{level:2,title:"递归调用",slug:"递归调用",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:4}]},readingTime:{minutes:.92,words:276},filePathRelative:"code/language/js/function/call.md"}}}]);