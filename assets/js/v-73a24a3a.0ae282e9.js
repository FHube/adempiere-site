"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[93882],{74228:(n,e,s)=>{s.r(e),s.d(e,{default:()=>o});var a=s(34086);const l=(0,a.uE)('<p>看到类似 <code>__slots__</code> 这种形如 <code>__xxx__</code> 的变量或者函数名就要注意，这些在 Python 中是有特殊用途的。</p><p><code>__slots__</code> 我们已经知道怎么用了，<code>__len__()</code> 方法我们也知道是为了能让 class 作用于 <code>len()</code> 函数。</p><p>除此之外，Python 的 class 中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p><h2 id="str" tabindex="-1"><a class="header-anchor" href="#str" aria-hidden="true">#</a> <code>__str__</code></h2><p>我们先定义一个 Student 类，打印一个实例:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n&gt;&gt;&gt; print(Student(&#39;Michael&#39;))\n&lt;__main__.Student object at 0x109afb190&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>打印出一堆 <code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p><p>怎么才能打印得好看呢？只需要定义好 <code>__str__()</code> 方法，返回一个好看的字符串就可以了:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return &#39;Student object (name: %s)&#39; % self.name\n...\n&gt;&gt;&gt; print(Student(&#39;Michael&#39;))\nStudent object (name: Michael)\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><p>但是细心的朋友会发现直接敲变量不用 <code>print</code>，打印出来的实例还是不好看:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)\n&gt;&gt;&gt; s\n&lt;__main__.Student object at 0x109afb310&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这是因为直接显示变量调用的不是 <code>__str__()</code>，而是 <code>__repr__()</code>，两者的区别是 <code>__str__()</code> 返回用户看到的字符串，而 <code>__repr__()</code> 返回程序开发者看到的字符串，也就是说，<code>__repr__()</code> 是为调试服务的。</p><p>解决办法是再定义一个 <code>__repr__()</code>。但是通常 <code>__str__()</code> 和 <code>__repr__()</code> 代码都是一样的，所以，有个偷懒的写法:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return &#39;Student object (name=%s)&#39; % self.name\n    __repr__ = __str__\n__iter__\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果一个类想被用于 <code>for ... in</code> 循环，类似 list 或 tuple 那样，就必须实现一个 <code>__iter__()</code> 方法，该方法返回一个迭代对象，然后，Python 的 for 循环就会不断调用该迭代对象的 <code>__next__()</code> 方法拿到循环的下一个值，直到遇到 <code>StopIteration</code> 错误时退出循环。</p><p>我们以斐波那契数列为例，写一个 <code>Fib</code> 类，可以作用于 for 循环:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a &gt; 100000: # 退出循环的条件\n            raise StopIteration()\n        return self.a # 返回下一个值\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>现在，试试把 <code>Fib</code> 实例作用于 for 循环:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; for n in Fib():\n...     print(n)\n...\n1\n1\n2\n3\n5\n...\n46368\n75025\n__getitem__\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>Fib</code> 实例虽然能作用于 for 循环，看起来和 <code>list</code> 有点像，但是，把它当成 <code>list</code> 来使用还是不行，比如，取第 5 个元素:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; Fib()[5]\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: &#39;Fib&#39; object does not support indexing\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>要表现得像 list 那样按照下标取出元素，需要实现 <code>__getitem__()</code> 方法:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Fib(object):\n    def __getitem__(self, n):\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>现在，就可以按下标访问数列的任意一项了:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f = Fib()\n&gt;&gt;&gt; f[0]\n1\n&gt;&gt;&gt; f[1]\n1\n&gt;&gt;&gt; f[2]\n2\n&gt;&gt;&gt; f[3]\n3\n&gt;&gt;&gt; f[10]\n89\n&gt;&gt;&gt; f[100]\n573147844013817084101\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>但是 <code>list</code> 有个神奇的切片方法:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; list(range(100))[5:10]\n[5, 6, 7, 8, 9]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于 Fib 却报错。原因是 <code>__getitem__()</code> 传入的参数可能是一个 <code>int</code>，也可能是一个切片对象 <code>slice</code>，所以要做判断:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x &gt;= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>现在试试 <code>Fib</code> 的切片:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f = Fib()\n&gt;&gt;&gt; f[0:5]\n[1, 1, 2, 3, 5]\n&gt;&gt;&gt; f[:10]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但是没有对 step 参数作处理:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f[:10:2]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也没有对负数作处理，所以，要正确实现一个 <code>__getitem__()</code> 还是有很多工作要做的。</p><p>此外，如果把对象看成 dict，<code>__getitem__()</code> 的参数也可能是一个可以作 <code>key</code> 的 <code>object</code>，例如 <code>str</code>。</p><p>与之对应的是 <code>__setitem__()</code> 方法，把对象视作 <code>list</code> 或 <code>dict</code> 来对集合赋值。最后，还有一个 <code>__delitem__()</code> 方法，用于删除某个元素。</p><p>总之，通过上面的方法，我们自己定义的类表现得和 Python 自带的 <code>list</code>、<code>tuple</code>、<code>dict</code> 没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p><h2 id="getattr" tabindex="-1"><a class="header-anchor" href="#getattr" aria-hidden="true">#</a> <code>__getattr__</code></h2><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义 <code>Student</code> 类:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n\n    def __init__(self):\n        self.name = &#39;Michael&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>调用 <code>name</code> 属性，没问题，但是，调用不存在的 <code>score</code> 属性，就有问题了:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; s = Student()\n&gt;&gt;&gt; print(s.name)\nMichael\n&gt;&gt;&gt; print(s.score)\nTraceback (most recent call last):\n  ...\nAttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>错误信息很清楚地告诉我们，没有找到 <code>score</code> 这个 <code>attribute</code>。</p><p>要避免这个错误，除了可以加上一个 <code>score</code> 属性外，Python 还有另一个机制，那就是写一个 <code>__getattr__()</code> 方法，动态返回一个属性。修改如下:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n\n    def __init__(self):\n        self.name = &#39;Michael&#39;\n\n    def __getattr__(self, attr):\n        if attr==&#39;score&#39;:\n            return 99\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当调用不存在的属性时，比如 <code>score</code>，Python 解释器会试图调用 <code>__getattr__(self, &#39;score&#39;)</code> 来尝试获得属性，这样，我们就有机会返回 <code>score</code> 的值:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; s = Student()\n&gt;&gt;&gt; s.name\n&#39;Michael&#39;\n&gt;&gt;&gt; s.score\n99\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>返回函数也是完全可以的:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n\n    def __getattr__(self, attr):\n        if attr==&#39;age&#39;:\n            return lambda: 25\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>只是调用方式要变为:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; s.age()\n25\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意，只有在没有找到属性的情况下，才调用 <code>__getattr__</code>，已有的属性，比如 <code>name</code>，不会在 <code>__getattr__</code> 中查找。</p><p>此外，注意到任意调用如 <code>s.abc</code> 都会返回 <code>None</code>，这是因为我们定义的 <code>__getattr__</code> 默认返回就是 <code>None</code>。要让 class 只响应特定的几个属性，我们就要按照约定，抛出 <code>AttributeError</code> 的错误:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n\n    def __getattr__(self, attr):\n        if attr==&#39;age&#39;:\n            return lambda: 25\n        raise AttributeError(&#39;\\&#39;Student\\&#39; object has no attribute \\&#39;%s\\&#39;&#39; % attr)\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p><p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p><p>举个例子:</p><p>现在很多网站都搞 REST API，比如新浪微博、豆瓣啥的，调用 API 的 URL 类似:</p><ul><li><code>http://api.server/user/friends</code></li><li><code>http://api.server/user/timeline/list</code></li></ul><p>如果要写 SDK，给每个 URL 对应的 API 都写一个方法，那得累死，而且，API 一旦改动，SDK 也要改。</p><p>利用完全动态的 <code>__getattr__</code>，我们可以写出一个链式调用:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Chain(object):\n\n    def __init__(self, path=&#39;&#39;):\n        self._path = path\n\n    def __getattr__(self, path):\n        return Chain(&#39;%s/%s&#39; % (self._path, path))\n\n    def __str__(self):\n        return self._path\n\n    __repr__ = __str__\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>试试:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; Chain().status.user.timeline.list\n&#39;/status/user/timeline/list&#39;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样，无论 API 怎么变，SDK 都可以根据 URL 实现完全动态的调用，而且，不随 API 的增加而改变!</p><p>还有些 REST API 会把参数放到 URL 中，比如 GitHub 的 API:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>GET /users/:user/repos\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>调用时，需要把 <code>:user</code> 替换为实际用户名。如果我们能写出这样的链式调用:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>Chain().users(&#39;michael&#39;).repos\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>就可以非常方便地调用 API 了。有兴趣的童鞋可以试试写出来。</p><h2 id="call" tabindex="-1"><a class="header-anchor" href="#call" aria-hidden="true">#</a> <code>__call__</code></h2><p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用 <code>instance.method()</code> 来调用。能不能直接在实例本身上调用呢？在 Python 中，答案是肯定的。</p><p>任何类，只需要定义一个 <code>__call__()</code> 方法，就可以直接对实例进行调用。请看示例:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>class Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print(&#39;My name is %s.&#39; % self.name)\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>调用方式如下:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)\n&gt;&gt;&gt; s() # self参数不要传入\nMy name is Michael.\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>__call__()</code> 还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以您完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>如果您把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p><p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个 Callable 对象，比如函数和我们上面定义的带有 <code>__call__()</code> 的类实例:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; callable(Student())\nTrue\n&gt;&gt;&gt; callable(max)\nTrue\n&gt;&gt;&gt; callable([1, 2, 3])\nFalse\n&gt;&gt;&gt; callable(None)\nFalse\n&gt;&gt;&gt; callable(&#39;str&#39;)\nFalse\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>通过 <code>callable()</code> 函数，我们就可以判断一个对象是否是“可调用”对象。</p>',82),r={class:"custom-container info"},p=(0,a._)("p",{class:"custom-container-title"},"相关信息",-1),t=(0,a.Uk)("更多可定制的方法，请参考 "),c={href:"http://docs.python.org/3/reference/datamodel.html#special-method-names",target:"_blank",rel:"noopener noreferrer"},i=(0,a.Uk)("Python 的官方文档"),d=(0,a.Uk)("。"),b={},o=(0,s(82831).Z)(b,[["render",function(n,e){const s=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,(0,a._)("div",r,[p,(0,a._)("p",null,[t,(0,a._)("a",c,[i,(0,a.Wm)(s)]),d])])],64)}]])},82831:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},87211:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-73a24a3a",path:"/code/language/python/oop/customize.html",title:"定制类",lang:"zh-CN",frontmatter:{title:"定制类",author:"廖雪峰",icon:"customize",date:"2021-03-28T00:00:00.000Z",category:["Python"],summary:"看到类似 slots 这种形如 xxx 的变量或者函数名就要注意，这些在 Python 中是有特殊用途的。 slots 我们已经知道怎么用了，len() 方法我们也知道是为了能让 class 作用于 len() 函数。 除此之外，Python 的 class 中还有许多这样有特殊用途的函数，可以帮助我们定制类。 str 我们先定义一个 Student 类，打",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/python/oop/customize.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"定制类"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"廖雪峰"}],["meta",{property:"article:published_time",content:"2021-03-28T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"",headers:[{level:2,title:"__str__",slug:"str",children:[]},{level:2,title:"__getattr__",slug:"getattr",children:[]},{level:2,title:"__call__",slug:"call",children:[]}],git:{createdTime:1616944982e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:2},{name:"Mister-Hope",email:"zhangbowang1998@gmail.com",commits:1}]},readingTime:{minutes:7.37,words:2212},filePathRelative:"code/language/python/oop/customize.md"}}}]);