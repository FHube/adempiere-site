"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[32343],{94908:(e,n,a)=>{a.r(n),a.d(n,{default:()=>d});var s=a(34086);const c=(0,s._)("p",null,"在上面的章节中我们看到了 JavaScript 的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。",-1),r=(0,s._)("p",null,"有没有更简单的写法? 有!",-1),t=(0,s._)("p",null,[(0,s.Uk)("新的关键字 "),(0,s._)("code",null,"class"),(0,s.Uk)(" 从 ES6 开始正式被引入到 JavaScript 中。"),(0,s._)("code",null,"class"),(0,s.Uk)(" 的目的就是让定义类更简单。")],-1),l=(0,s.uE)('<p>我们先回顾用函数实现 <code>Student</code> 的方法:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function Student(name) {\n  this.name = name;\n}\n\nStudent.prototype.hello = function () {\n  alert(`Hello, ${this.name}!`);\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果用新的 <code>class</code> 关键字来编写 <code>Student</code>，可以这样写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>class Student {\n  constructor(name) {\n    this.name = name;\n  }\n\n  hello() {\n    alert(`Hello, ${this.name}!`);\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>比较一下就可以发现，<code>class</code> 的定义包含了构造函数 <code>constructor</code> 和定义在原型对象上的函数 <code>hello()</code> (注意没有 <code>function</code> 关键字)，这样就避免了 <code>Student.prototype.hello = function () {...}</code> 这样分散的代码。</p><p>最后，创建一个 <code>Student</code> 对象代码和前面章节完全一样:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const xiaoming = new Student(&quot;小明&quot;);\n\nxiaoming.hello();\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>用 <code>class</code> 定义对象的另一个巨大的好处是继承更方便了。想一想我们从 <code>Student</code> 派生一个 <code>PrimaryStudent</code> 需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过 <code>extends</code> 来实现:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>class PrimaryStudent extends Student {\n  constructor(name, grade) {\n    super(name); // 记得用super调用父类的构造方法!\n    this.grade = grade;\n  }\n\n  myGrade() {\n    alert(`I am at grade ${this.grade}`);\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意 <code>PrimaryStudent</code> 的定义也是 <code>class</code> 关键字实现的，而 <code>extends</code> 则表示原型链对象来自 <code>Student</code>。子类的构造函数可能会与父类不太相同，例如，<code>PrimaryStudent</code> 需要 <code>name</code> 和 <code>grade</code> 两个参数，并且需要通过 <code>super(name)</code> 来调用父类的构造函数，否则父类的 <code>name</code> 属性无法正常初始化。</p><p><code>PrimaryStudent</code> 已经自动获得了父类 <code>Student</code> 的 <code>hello</code> 方法，我们又在子类中定义了新的 <code>myGrade</code> 方法。</p><p>ES6 引入的 <code>class</code> 和原有的 JavaScript 原型继承有什么区别呢? 实际上它们没有任何区别，<code>class</code> 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 <code>class</code> 的好处就是极大地简化了原型链代码。</p>',12),o={},d=(0,a(82831).Z)(o,[["render",function(e,n){return(0,s.wg)(),(0,s.iD)(s.HY,null,[c,r,t,(0,s.kq)(" more "),l],64)}]])},82831:(e,n)=>{n.Z=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},6057:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-54277b4e",path:"/code/language/js/object/class.html",title:"class 继承",lang:"zh-CN",frontmatter:{title:"class 继承",icon:"class",date:"2019-10-10T00:00:00.000Z",category:["JavaScript"],summary:"在上面的章节中我们看到了 JavaScript 的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。\n有没有更简单的写法? 有!\n新的关键字 class 从 ES6 开始正式被引入到 JavaScript 中。class 的目的就是让定义类更简单。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/object/class.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"class 继承"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:published_time",content:"2019-10-10T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"<p>在上面的章节中我们看到了 JavaScript 的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>\n<p>有没有更简单的写法? 有!</p>\n<p>新的关键字 <code v-pre>class</code> 从 ES6 开始正式被引入到 JavaScript 中。<code v-pre>class</code> 的目的就是让定义类更简单。</p>\n",headers:[],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:3}]},readingTime:{minutes:1.92,words:575},filePathRelative:"code/language/js/object/class.md"}}}]);