"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[47862],{6176:(n,e,a)=>{a.r(e),a.d(e,{default:()=>o});var s=a(34086);const r=(0,s._)("p",null,[(0,s._)("code",null,"generator"),(0,s.Uk)(" (生成器)是 ES6 标准引入的新的数据类型。一个 "),(0,s._)("code",null,"generator"),(0,s.Uk)(" 看上去像一个函数，但可以返回多次。")],-1),l=(0,s._)("p",null,[(0,s.Uk)("ES6 定义 "),(0,s._)("code",null,"generator"),(0,s.Uk)(" 标准的哥们借鉴了 Python 的 generator 的概念和语法，如果您对 Python 的 generator 很熟悉，那么 ES6 的 generator 就是小菜一碟了。")],-1),p=(0,s.uE)('<p>我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const foo = (x) =&gt; x + x;\n\nconst r = foo(1); // 调用foo函数\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>函数在执行过程中，如果没有遇到 <code>return</code> 语句(函数末尾如果没有 <code>return</code>，就是隐含的 <code>return undefined;</code>)，控制权无法交回被调用的代码。</p><p><code>generator</code> 跟函数很像，定义如下:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function* foo(x) {\n  yield x + 1;\n  yield x + 2;\n  return x + 3;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>generator</code> 和函数不同的是，<code>generator</code> 由 <code>function*</code> 定义(注意多出的 <code>*</code> 号)，并且，除了 <code>return</code> 语句，还可以用 <code>yield</code> 返回多次。</p><p>大多数同学立刻就晕了，<code>generator</code> 就是能够返回多次的“函数”? 返回多次有啥用?</p><p>还是举个栗子吧。</p><p>我们以一个著名的斐波那契数列为例，它由 0，1 开头:</p>',9),c=(0,s._)("p",{class:"katex-block"},[(0,s._)("span",{class:"katex-display"},[(0,s._)("span",{class:"katex"},[(0,s._)("span",{class:"katex-mathml"},[(0,s._)("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[(0,s._)("semantics",null,[(0,s._)("mrow",null,[(0,s._)("mn",null,"0"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"1"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"1"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"2"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"3"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"5"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"8"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mn",null,"13"),(0,s._)("mspace",{width:"1em"}),(0,s._)("mi",{mathvariant:"normal"},"."),(0,s._)("mi",{mathvariant:"normal"},"."),(0,s._)("mi",{mathvariant:"normal"},".")]),(0,s._)("annotation",{encoding:"application/x-tex"},"0\\quad1\\quad1\\quad2\\quad3\\quad5\\quad8\\quad13\\quad... ")])])]),(0,s._)("span",{class:"katex-html","aria-hidden":"true"},[(0,s._)("span",{class:"base"},[(0,s._)("span",{class:"strut",style:{height:"0.6444em"}}),(0,s._)("span",{class:"mord"},"0"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"1"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"1"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"2"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"3"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"5"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"8"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"13"),(0,s._)("span",{class:"mspace",style:{"margin-right":"1em"}}),(0,s._)("span",{class:"mord"},"...")])])])])],-1),t=(0,s.uE)('<p>要编写一个产生斐波那契数列的函数，可以这么写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function fib(max) {\n  let a = 0;\n  let b = 1;\n  const arr = [0, 1];\n\n  while (arr.length &lt; max) {\n    [a, b] = [b, a + b];\n    arr.push(b);\n  }\n\n  return arr;\n}\n\n// 测试:\nfib(5); // [0, 1, 1, 2, 3]\nfib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>函数只能返回一次，所以必须返回一个 Array。但是，如果换成 generator，就可以一次返回一个数，不断返回多次。用 generator 改写如下:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function* fib(max) {\n  let a = 0;\n  let b = 1;\n  let n = 0;\n\n  while (n &lt; max) {\n    yield a;\n    [a, b] = [b, a + b];\n    n++;\n  }\n\n  return;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>直接调用试试:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>fib(5); // fib {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>直接调用一个 <code>generator</code> 和调用函数不一样，<code>fib(5)</code> 仅仅是创建了一个 <code>generator</code> 对象，还没有去执行它。</p><p>调用 <code>generator</code> 对象有两个方法，一是不断地调用 <code>generator</code> 对象的 <code>next()</code> 方法:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const f = fib(5);\nf.next(); // {value: 0, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 2, done: false}\nf.next(); // {value: 3, done: false}\nf.next(); // {value: undefined, done: true}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>next()</code> 方法会执行 <code>generator</code> 的代码，然后，每次遇到 <code>yield x;</code> 就返回一个对象 <code>{value: x, done: true/false}</code>，然后“暂停”。返回的 <code>value</code> 就是 <code>yield</code> 的返回值，<code>done</code> 表示这个 <code>generator</code> 是否已经执行结束了。如果 <code>done</code> 为 <code>true</code>，则 <code>value</code> 就是 <code>return</code> 的返回值。</p><p>当执行到 <code>done</code> 为 <code>true</code> 时，这个 generator 对象就已经全部执行完毕，不要再继续调用 <code>next()</code> 了。</p><p>第二个方法是直接用 <code>for ... of</code> 循环迭代 generator 对象，这种方式不需要我们自己判断 <code>done</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>&quot;use strict&quot;;\n\nfunction* fib(max) {\n  let a = 0;\n  let b = 1;\n  let n = 0;\n\n  while (n &lt; max) {\n    yield a;\n    [a, b] = [b, a + b];\n    n++;\n  }\n}\n\nfor (let x of fib(10)) {\n  console.log(x); // 依次输出0, 1, 1, 2, 3, ...\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">generator 和普通函数相比，有什么用?</p><p>因为 generator 可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个 generator 就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const fib = {\n  a: 0,\n  b: 1,\n  n: 0,\n  max: 5,\n  next() {\n    let r = this.a;\n    let t = this.a + this.b;\n\n    this.a = this.b;\n    this.b = t;\n    if (this.n &lt; this.max) {\n      this.n++;\n      return r;\n    } else return undefined;\n  },\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>用对象的属性来保存状态，相当繁琐。</p><p>Generator 还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了 Ajax 以后才能体会到。</p><p>没有 generator 之前的黑暗时代，用 Ajax 时需要这么写代码:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>ajax(&#39;https://url-1&#39;, data1, (err, result) =&gt; {\n  if (err) return handle(err);\n\n  ajax(&#39;https://url-2&#39;, data2, (err, result) =&gt; {\n    if (err) return handle(err);\n\n    ajax(&#39;https://url-3&#39;, data3, (err, result) =&gt;\n      err? handle(err): success(result);\n    });\n  });\n});\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>回调越多，代码越难看。</p><p>有了 generator 的美好时代，用 Ajax 时可以这么写:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>try {\n  r1 = yield ajax(&#39;https://url-1&#39;, data1);\n  r2 = yield ajax(&#39;https://url-2&#39;, data2);\n  r3 = yield ajax(&#39;https://url-3&#39;, data3);\n  success(r3);\n} catch (err) {\n  handle(err);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>看上去是同步的代码，实际执行是异步的。</p></div>',14),i={},o=(0,a(82831).Z)(i,[["render",function(n,e){return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,l,(0,s.kq)(" more "),p,c,t],64)}]])},82831:(n,e)=>{e.Z=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},36575:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-88b653b6",path:"/code/language/js/function/generator.html",title:"generator",lang:"zh-CN",frontmatter:{title:"generator",icon:"cycle",date:"2019-10-07T00:00:00.000Z",category:["JavaScript"],summary:"generator (生成器)是 ES6 标准引入的新的数据类型。一个 generator 看上去像一个函数，但可以返回多次。\nES6 定义 generator 标准的哥们借鉴了 Python 的 generator 的概念和语法，如果您对 Python 的 generator 很熟悉，那么 ES6 的 generator 就是小菜一碟了。\n",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/js/function/generator.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"generator"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:published_time",content:"2019-10-07T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"<p><code v-pre>generator</code> (生成器)是 ES6 标准引入的新的数据类型。一个 <code v-pre>generator</code> 看上去像一个函数，但可以返回多次。</p>\n<p>ES6 定义 <code v-pre>generator</code> 标准的哥们借鉴了 Python 的 generator 的概念和语法，如果您对 Python 的 generator 很熟悉，那么 ES6 的 generator 就是小菜一碟了。</p>\n",headers:[],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:10}]},readingTime:{minutes:3.52,words:1055},filePathRelative:"code/language/js/function/generator.md"}}}]);