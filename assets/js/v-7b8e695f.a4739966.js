"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[84945],{79739:(n,e,a)=>{a.r(e),a.d(e,{default:()=>l});const s=(0,a(34086).uE)('<h2 id="函数作为返回值" tabindex="-1"><a class="header-anchor" href="#函数作为返回值" aria-hidden="true">#</a> 函数作为返回值</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def calc_sum(*args):\n    ax = 0\n    for n in args:\n        ax = ax + n\n    return ax\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办? 可以不返回求和的结果，而是返回求和的函数:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>当我们调用 <code>lazy_sum()</code> 时，返回的并不是求和结果，而是求和函数:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)\n&gt;&gt;&gt; f\n&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>调用函数 <code>f</code> 时，才真正计算求和的结果:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f()\n25\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个例子中，我们在函数 <code>lazy_sum</code> 中又定义了函数 <code>sum</code>，并且，内部函数 <code>sum</code> 可以引用外部函数 <code>lazy_sum</code> 的参数和局部变量，当 <code>lazy_sum</code> 返回函数 sum 时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用 <code>lazy_sum()</code> 时，每次调用都会返回一个新的函数，即使传入相同的参数:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)\n&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)\n&gt;&gt;&gt; f1==f2\nFalse\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>f1()</code> 和 <code>f2()</code> 的调用结果互不影响。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>注意到返回的函数在其定义内部引用了局部变量 <code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 <code>f()</code> 才执行。我们来看一个例子:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的 3 个函数都返回了。</p><p>您可能认为调用 <code>f1()</code>，<code>f2()</code> 和 <code>f3()</code> 结果应该是 <code>1</code>，<code>4</code>，<code>9</code>，但实际结果是:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f1()\n9\n&gt;&gt;&gt; f2()\n9\n&gt;&gt;&gt; f3()\n9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>全部都是 <code>9</code>! 原因就在于返回的函数引用了变量 <code>i</code>，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量 <code>i</code> 已经变成了 <code>3</code>，因此最终结果为 <code>9</code>。</p><div class="custom-container warning"><p class="custom-container-title">注意</p><p>返回闭包时牢记一点:返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p></div><p>如果一定要引用循环变量怎么办? 方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>def count():\n    def f(j):\n        def g():\n            return j*j\n        return g\n    fs = []\n    for i in range(1, 4):\n        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()\n    return fs\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>再看看结果:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>&gt;&gt;&gt; f1, f2, f3 = count()\n&gt;&gt;&gt; f1()\n1\n&gt;&gt;&gt; f2()\n4\n&gt;&gt;&gt; f3()\n9\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>缺点是代码较长，可利用 lambda 函数缩短代码。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>一个函数可以返回一个计算结果，也可以返回一个函数。</p><p>返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。</p>',31),r={},l=(0,a(82831).Z)(r,[["render",function(n,e){return s}]])},82831:(n,e)=>{e.Z=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},49303:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-7b8e695f",path:"/code/language/python/functional-programming/return-function.html",title:"返回函数",lang:"zh-CN",frontmatter:{title:"返回函数",icon:"return",author:"廖雪峰",date:"2020-06-02T00:00:00.000Z",category:["Python"],summary:"函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的: 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办? 可以不返回求和的结果，而是返回求和的函数: 当我们调用 lazy_sum() 时，返回的并不是求和结果，而是求和函数: 调用函数 f 时，才",head:[["meta",{property:"og:url",content:"https://mrhope.site/code/language/python/functional-programming/return-function.html"}],["meta",{property:"og:site_name",content:"Mr.Hope"}],["meta",{property:"og:title",content:"返回函数"}],["meta",{property:"og:type",content:"article"}],["meta",{property:"og:updated_time",content:"2022-02-06T16:46:58.000Z"}],["meta",{property:"og:locale",content:"zh-CN"}],["meta",{property:"article:author",content:"廖雪峰"}],["meta",{property:"article:published_time",content:"2020-06-02T00:00:00.000Z"}],["meta",{property:"article:modified_time",content:"2022-02-06T16:46:58.000Z"}]]},excerpt:"",headers:[{level:2,title:"函数作为返回值",slug:"函数作为返回值",children:[]},{level:2,title:"闭包",slug:"闭包",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],git:{createdTime:1591204114e3,updatedTime:1644166018e3,contributors:[{name:"Mr.Hope",email:"zhangbowang1998@gmail.com",commits:6},{name:"Mister-Hope",email:"zhangbowang1998@gmail.com",commits:1}]},readingTime:{minutes:2.88,words:864},filePathRelative:"code/language/python/functional-programming/return-function.md"}}}]);